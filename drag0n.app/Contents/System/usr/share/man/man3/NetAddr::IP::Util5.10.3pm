.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2010-05-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Util \-\- IPv4/6 and 128 bit number utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Util qw(
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :inet   =>    inet_aton, inet_ntoa, ipv6_aton,
\&                ipv6_n2x, ipv6_n2d, inet_any2n,
\&                inet_n2dx, inet_n2ad, ipv4to6,
\&                mask4to6, ipanyto6, maskanyto6,
\&                ipv6to4
\&
\&  :ipv4   =>    inet_aton, inet_ntoa
\&
\&  :ipv6   =>    ipv6_aton, ipv6_n2x, ipv6_n2d,
\&                inet_any2n, inet_n2dx, inet_n2ad
\&                ipv4to6, mask4to6, ipanyto6,
\&                maskanyto6, ipv6to4
\&
\&  :math   =>    hasbits, isIPv4, addconst,
\&                add128, sub128, notcontiguous,
\&                bin2bcd, bcd2bin, shiftleft
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $rv = hasbits($bits128);
\&  $rv = isIPv4($bits128);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
\&  $modetext = mode;
\&
\&  NetAddr::IP::Util::lower();
\&  NetAddr::IP::Util::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Util\fR installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::Util\fR provides a suite of tools for manipulating and
converting IPv4 and IPv6 addresses into 128 bit string context and back to
text. The strings can be manipulated with Perl's logical operators:
.PP
.Vb 4
\&        and     &
\&        or      |
\&        xor     ^
\&                ~       compliment
.Ve
.PP
in the same manner as 'vec' strings.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 network address/mask into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: a single shift is performed
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2\s0 +1 to the \s-1ARG1\s0. It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr number
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.IP "\(bu" 4
\&\f(CW$modetext\fR = mode;
.Sp
Returns the operating mode of this module.
.Sp
.Vb 3
\&        input:          none
\&        returns:        "Pure Perl"
\&                   or   "CC XS"
.Ve
.IP "\(bu" 4
\&\fINetAddr::IP::Util::lower()\fR;
.Sp
Return IPv6 strings in lowercase.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::upper()\fR;
.Sp
Return IPv6 strings in uppercase.  This is the default.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\&  # convert any textual IP address into a 128 bit vector
\&  #
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    unless (hasbits($mask & $notiv4)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&  ... alternate implementation, a little faster
\&
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    if (isIPv4($mask)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&
\&  ... elsewhere
\&    $nip = {
\&        addr    => $vecip,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&
\&  # return network and broadcast addresses from IP and Mask
\&  #
\&  sub netbroad {
\&    my($nip) = shift;
\&    my $notmask = ~ $nip\->{mask};
\&    my $bcast   = $nip\->{addr} | $notmask;
\&    my $network = $nip\->{addr} & $nip\->{mask};
\&    return ($network, $broadcast);
\&  }
\&
\&  # check if address is within a network
\&  #
\&  sub within {
\&    my($nip,$net) = @_;
\&    my $addr = $nip\->{addr}
\&    my($nw,$bc) = netbroad($net);
\&  # arg1 >= arg2, sub128 returns true
\&    return (sub128($addr,$nw) && sub128($bc,$addr))
\&        ? 1 : 0;
\&  }
\&
\&  # add a constant, wrapping at netblock boundaries
\&  # to subtract the constant, negate it before calling
\&  # \*(Aqaddwrap\*(Aq since \*(Aqaddconst\*(Aq will extend the sign bits
\&  #
\&  sub addwrap {
\&    my($nip,$const) = @_;
\&    my $mask    = $nip\->{addr};
\&    my $bits    = $nip\->{bits};
\&    my $notmask = ~ $mask;
\&    my $hibits  = $addr & $mask;
\&    my $addr = addconst($addr,$const);
\&    my $wraponly = $addr & $notmask;
\&    my $newip = {
\&        addr    => $hibits | $wraponly,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&    # bless $newip as appropriate
\&    return $newip;
\&  }
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
The following functions are used in whole or in part as include files to
Util.xs. The copyright is include in the file.
.PP
.Vb 1
\&  file:              function:
\&
\&  miniSocket.inc  inet_aton, inet_ntoa
.Ve
.PP
inet_aton, inet_ntoa are from the perl\-5.8.0 release by Larry Wall, copyright
1989\-2002. inet_aton, inet_ntoa code is current through perl\-5.9.3 release.
Thank you Larry for making \s-1PERL\s0 possible for all of us.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2010, Michael Robinton <michael@bizsystems.com>
.PP
\&\s-1LICENSE\s0 \s-1AND\s0 \s-1WARRANTY\s0
.PP
This software is (c) Michael Robinton.  It can be used under the terms of
the perl artistic license provided  that proper credit for the work of
the  author is  preserved in  the form  of this  copyright  notice and
license for this module.
.PP
No warranty of any kind is  expressed or implied, by using it
you accept any and all the liability.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
