.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glue 3"
.TH Glue 3 "2007-01-03" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Glue \- Control Mac apps with Apple event terminology
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        use Mac::Glue;
\&        my $glue = Mac::Glue\->new(\*(AqFinder\*(Aq);
\&        $glue\->prop(\*(AqSystem Folder\*(Aq)\->open;
\&        # see rest of docs for lots more info
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\*(L"Mac::Glue does AppleScript so you don't have to.\*(R"
.PP
If you have MacPerl \fIearlier\fR than 5.6, you should have the latest
cpan-mac distribution:
.PP
.Vb 1
\&        http://sf.net/projects/cpan\-mac/
.Ve
.PP
For Mac \s-1OS\s0 X, you should have the latest Mac::Carbon distribution:
.PP
.Vb 1
\&        http://projects.pudge.net/
.Ve
.PP
Also see projects.pudge.net for more information, support, \s-1CVS\s0, etc.
.PP
Mac \s-1OS\s0 apps speak to each other with a \fIlingua franca\fR called \fBApple
events\fR.  The most common way to do Apple events (aside from doaing them
in a precompiled application with C, Pascal, etc.) is with
AppleScript.  Other languages can do Apple events too, like Frontier and
even Python.  But we like Perl.
.PP
MacPerl has for a few years had an interface to Apple events, with the
Mac::AppleEvents module, which is the basis for everything we'll do
here.  Mac::AppleEvents::Simple was made to simplify the process of
doing Apple events in MacPerl, but even that can be too much trouble to
use.  One has to find out the class and event IDs, find out the keywords
and data types for each parameter, etc.
.PP
So the vision was born for a framework that wouldn't take much
significant work.  An application's \s-1AETE\s0 resource would provide the
names to match to the cryptic four-character codes we had been using. 
Compare.
.IP "Raw Mac::AppleEvents method" 4
.IX Item "Raw Mac::AppleEvents method"
.Vb 2
\&        use Mac::AppleEvents;
\&        use Mac::Errors \*(Aq$MacError\*(Aq;
\&
\&        $evt = AEBuildAppleEvent(\*(Aqaevt\*(Aq, \*(Aqodoc\*(Aq, typeApplSignature, \*(AqMACS\*(Aq,
\&                kAutoGenerateReturnID, kAnyTransactionID,
\&                "\*(Aq\-\-\-\-\*(Aq: obj{want:type(prop), from:\*(Aqnull\*(Aq()," . 
\&                "form:prop, seld:type(macs)}"
\&        ) or die $MacError;
\&        $rep = AESend($evt, kAEWaitReply) or die $MacError;
\&
\&        AEDisposeDesc($evt);
\&        AEDisposeDesc($rep);
.Ve
.IP "Easier Mac::AppleEvents::Simple method" 4
.IX Item "Easier Mac::AppleEvents::Simple method"
.Vb 5
\&        use Mac::AppleEvents::Simple;
\&        do_event(qw(aevt odoc MACS),
\&                "\*(Aq\-\-\-\-\*(Aq: obj{want:type(prop), from:\*(Aqnull\*(Aq()," . 
\&                "form:prop, seld:type(macs)}"
\&        );
.Ve
.IP "Cool Mac::Glue method" 4
.IX Item "Cool Mac::Glue method"
.Vb 3
\&        use Mac::Glue;
\&        my $glue = Mac::Glue\->new(\*(AqFinder\*(Aq);
\&        $glue\->open( $glue\->prop(\*(AqSystem Folder\*(Aq) );
.Ve
.PP
The latter is much simpler to understand, to read, to write.  It
leverages the user's understanding of AppleScript.  And it is just more
natural.
.PP
There are downsides.  Mac::Glue is less powerful than the
Mac::AppleEvents raw interfaces, because it offers less flexibility
in how events are called.  It is also slower to start a script,
because the glue structures need to be loaded in.  However, once a
script has started, a difference in speed from the raw interfaces should
be minimal (though not a lot of testing has been done on that).  With the
code above, on a PowerBook G3/292, running Mac \s-1OS\s0 8.6:
.PP
.Vb 5
\&    Benchmark: timing 100 iterations of glue, glue2, raw, simple...
\&          glue: 10 secs ( 9.98 usr  0.00 sys =  9.98 cpu)
\&         glue2:  8 secs ( 8.35 usr  0.00 sys =  8.35 cpu)
\&           raw:  8 secs ( 7.88 usr  0.00 sys =  7.88 cpu)
\&        simple:  7 secs ( 7.50 usr  0.00 sys =  7.50 cpu)
.Ve
.PP
The \*(L"glue2\*(R" entry is the same as \*(L"glue\*(R" entry, but it creates a glue
object only once instead of each time through, cutting down on the
overhead.  It appears that Mac::Glue is a bit slower than the other
methods, but not substantially, and it is cooler and easier.
The one place where performance is the biggest problem is on
initial execution of the program, but once it starts it is plenty fast.
We'll work to cut down that start time, too.
.PP
So, now that you are convinced this is cool, let's continue.
.SS "Mac \s-1OS\s0 X"
.IX Subsection "Mac OS X"
Mac \s-1OS\s0 X is supported by Mac::Glue now.  Note that some glues and methods
will behave differently, due to differences in application implementation
(for example, the Finder's \*(L"clean up\*(R" event is not supported in Mac \s-1OS\s0 X
at this writing).
.SS "Creating a Glue"
.IX Subsection "Creating a Glue"
In order to script an application with Mac::Glue, a glue must be created
first.  For that, the application is passed to the \fIgluemac\fR script.
A distribution called Mac::AETE, created by David Schooley, is used to
parse an application's \s-1AETE\s0 resource, and the glue is written out to a
file using Storable, DB_File, and \s-1MLDBM\s0.  Glues are saved in
\&\f(CW$ENV\fR{\s-1MACGLUEDIR\s0} (which is defined when Mac::Glue is used if it is not
defined already).  By default for MacPerl, glues are stored in
\&\fI:site_perl:Mac:Glue:glues:\fR, or in \fI./Glue/glues\fR relative to
\&\fIGlue.pm\fR for Unix (Mac \s-1OS\s0 X).
.PP
All glues have access to the global scripting additions and dialect
information.  Glues for these must be created as well, and are created
with the \fIgluescriptadds\fR and \fIgluedialect\fR programs, which are
similar to the \fIgluemac\fR program.  They are saved in the directories
\&\fI\f(CI$ENV\fI{\s-1MACGLUEDIR\s0}additions\fR and \fI\f(CI$ENV\fI{\s-1MACGLUEDIR\s0}dialects\fR.
.PP
Along with the glue file is a \s-1POD\s0 file containing documentation for the
glue, listing all the events (with parameters), classes (with
properties), and enumerators, and descriptions of each.
.SS "Using a Glue"
.IX Subsection "Using a Glue"
The first thing you do is call the module.
.PP
.Vb 1
\&        use Mac::Glue;
.Ve
.PP
Then you create an object for your app by passing the \f(CW\*(C`new\*(C'\fR function
the name of the glue (you may include or omit underscores in the name if
you like).
.PP
.Vb 1
\&        my $glue = Mac::Glue\->new(\*(AqMy App\*(Aq);  # or My_App
.Ve
.PP
You can also pass in additional parameters for the type of target to use.
.IP "\(bu" 4
Bundle \s-1ID\s0 (Mac \s-1OS\s0 X only)
.Sp
.Vb 1
\&        Mac::Glue\->new(\*(AqMy App\*(Aq, bundle => \*(Aqcom.example.MyApp\*(Aq);
.Ve
.IP "\(bu" 4
Process Serial Number
.Sp
.Vb 1
\&        Mac::Glue\->new(\*(AqMy App\*(Aq, psn => $psn);
.Ve
.IP "\(bu" 4
Process \s-1ID\s0 (Mac \s-1OS\s0 X only)
.Sp
.Vb 1
\&        Mac::Glue\->new(\*(AqMy App\*(Aq, pid => $pid);
.Ve
.IP "\(bu" 4
Application path
.Sp
.Vb 1
\&        Mac::Glue\->new(\*(AqMy App\*(Aq, path => $path_to_file_or_bundle);
.Ve
.IP "\(bu" 4
AppleTalk (Mac \s-1OS\s0 only)
.Sp
.Vb 2
\&        Mac::Glue\->new(\*(AqMy App\*(Aq, ppc => \*(AqMy App Name\*(Aq,
\&                \*(AqServer Name\*(Aq, \*(AqZone\*(Aq);
.Ve
.IP "\(bu" 4
Application \s-1URL\s0
.Sp
.Vb 2
\&        Mac::Glue\->new(\*(AqMy App\*(Aq, eppc => \*(AqMy App Name\*(Aq, \*(Aqmac.example.com\*(Aq,
\&                $uid, $pid, $user, $pass);
.Ve
.Sp
\&\s-1UID\s0, \s-1PID\s0, user, pass are optional (and ignored entirely for Mac \s-1OS\s0 9).  It
is recommended to use the Keychain to handle user/pass (just omit them, and
you'll be prompted in a dialog box for them, with an option for the Keychain
to remember them).
.Sp
\&\s-1UID\s0 and \s-1PID\s0 are used if there's more than one target application, though
these don't currently work in my tests.
.PP
Addresses can be changed after the fact:
.PP
.Vb 1
\&        $glue\->ADDRESS(eppc => \*(AqMy App Name\*(Aq, \*(Aqmac.example.com\*(Aq);
.Ve
.PP
And to reset the address to the default, call the method with no parameters:
.PP
.Vb 1
\&        $glue\->ADDRESS;
.Ve
.PP
Once you have your glue set up, you start calling events, as they are
documented in the \s-1POD\s0 file for the glue.  The events can be called
case-insensitively, with the exception of those that match the names of
the special methods (see \*(L"Special parameters and methods\*(R").  In that
case, since the special methods are in all caps, the event methods can
be called case-insensitively except for all caps.  e.g., for an event
named \f(CW\*(C`reply\*(C'\fR, it could be called with:
.PP
.Vb 3
\&        $glue\->Reply;
\&        $glue\->reply;
\&        $glue\->RePLY;
.Ve
.PP
However, it could not be called with \f(CW\*(C`$glue\->REPLY\*(C'\fR, since that
is reserved.
.PP
All applications respond to events differently.  Something that works for
one application might not work for another, so don't use any of these examples
as a way you should script a specific application.  They are just hyopthetical
examples, for the most part.
.PP
Events sometimes accept parameters, sometimes they don't.  The primary
parameter of most events is a special parameter called the \fIdirect
object\fR parameter.  In your event call, pass the data for that parameter
first:
.PP
.Vb 1
\&        $glue\->open($file);
.Ve
.PP
Other parameters must be named and must be provided as key-value pairs,
with the key as the name of the parameter, and the value as the
parameter's data:
.PP
.Vb 1
\&        $glue\->open($file, using => $myapp);
.Ve
.PP
Note that the direct object parameter is the only parameter that doesn't
need a name in front of it, and must come first in the list if it is
supplied at all.
.PP
Mac::Glue will attempt to coerce passed data into the expected type. 
For example, if \f(CW\*(C`open\*(C'\fR expects an alias, the file specification in
\&\f(CW$file\fR will be turned into an alias before being added to the event.
.PP
You can override this behavior with the \f(CW\*(C`param_type\*(C'\fR function.  If
\&\f(CW\*(C`open\*(C'\fR expects an alias (\f(CW\*(C`typeAlias\*(C'\fR), but you want to pass text,
you can do:
.PP
.Vb 1
\&        $glue\->open( param_type(typeChar, $path) );
.Ve
.PP
Each datum can be a simple scalar as above, an AEDesc object,
an Mac::AEObjDesc object (returned by \f(CW\*(C`obj\*(C'\fR, \f(CW\*(C`prop\*(C'\fR, and event methods),
an Mac::AEEnum object (returned by the \f(CW\*(C`enum\*(C'\fR function, see \s-1EXPORT\s0),
or an array or hash reference, corresponding to \s-1AE\s0 lists and records.
In this example, we nest them, with an arrayref as one of the values in
the hashref, so the \s-1AE\s0 list is a datum for one of the keys in the \s-1AE\s0 record:
.PP
.Vb 2
\&        $glue\->make(new => \*(Aqwindow\*(Aq, with_properties =>
\&                { name => "New Window", position => [100, 200] });
.Ve
.PP
The words \*(L"name\*(R" and \*(L"position\*(R" will be changed into the proper
corresponding \s-1AE\s0 IDs.  And on return, record keys will be changed back
from the \s-1AE\s0 IDs into the English words.
.PP
Events return direct object parameters, turned into suitable data for
use in the program.  Aliases are resolved into file specifications, \s-1AE\s0
records and lists are turned into Perl hashes and arrays (recursively,
for nested lists), etc.
.PP
.Vb 2
\&        my @urls = $sherlock\->search_internet(\*(AqAltaVista\*(Aq,
\&                for => \*(AqMac::Glue\*(Aq);
.Ve
.PP
\&\s-1AE\s0 objects (which will be discussed later) are returned as \f(CW\*(C`Mac::AEObjDesc\*(C'\fR
objects, so they may be used again by being passed back to another
event.
.PP
.Vb 2
\&        my $window_object = $glue\->get( window => 1 );
\&        $glue\->save($window_object);
.Ve
.PP
This allows AppleScript-like loops:
.PP
.Vb 5
\&        my @selection = $glue\->get( $glue\->prop(selection => of => window) );
\&        my @owners;
\&        for my $item (@selection) {
\&                push @owners, $glue\->get( $glue\->obj(cell => \*(AqOwners\*(Aq => $item) );
\&        }
.Ve
.PP
Some objects may allow an easy way to get a human-readable form, with the
\&\f(CW\*(C`as\*(C'\fR parameter:
.PP
.Vb 1
\&        my $item = $glue\->get( file => 1, as => \*(Aqstring\*(Aq );
.Ve
.PP
Errors are returned in the special variable \f(CW$^E\fR, which should be
checked immediately after an event call (for portability with Mac \s-1OS\s0 X,
use \f(CW$MacError\fR instead for the value):
.PP
.Vb 4
\&        $glue\->close(window => 1);
\&        if ($^E) {
\&                warn "Couldn\*(Aqt close window: $MacError\en";
\&        }
.Ve
.PP
Or, if a value is expected and none is returned:
.PP
.Vb 2
\&        my $file = $glue\->choose_file(\*(AqSelect a file, please.\*(Aq)
\&                or die "No file chosen: $MacError";
.Ve
.PP
Checking \f(CW$^E\fR only works if the error returned is an error number.
If it isn't, the actual error is available from the reply event,
which can be accessed by using the \f(CW\*(C`RETOBJ\*(C'\fR parameter (described
below in \*(L"Special parameters and methods\*(R").
.PP
You can also handle errors with the \f(CW\*(C`ERRORS\*(C'\fR handlers (also
described below in \*(L"Special parameters and methods\*(R").
.SS "Creating object specifier records"
.IX Subsection "Creating object specifier records"
This is one of the more complex parts of Apple events, and it is only
partially implemented (though full implementation is expected
eventually, and most of it is implemented now).
.PP
Object specifier records are created by the \f(CW\*(C`obj\*(C'\fR method, and have
four components to them.
.IP "class" 4
.IX Item "class"
.PD 0
.IP "container" 4
.IX Item "container"
.IP "form" 4
.IX Item "form"
.IP "data" 4
.IX Item "data"
.PD
.PP
The class and data are passed as key-value pairs, like in \s-1AE\s0 records or
parameter lists.  The form and the type of the data are determined by
the glue data or a good guess.  The container is determined by the order
of the key-value pairs: each pair is contained by the pair or object that
follows it.
.PP
.Vb 1
\&        my $obj = $glue\->obj(file => \*(Aqfoo\*(Aq, folder => \*(Aqbar\*(Aq, disk => \*(Aqbuz\*(Aq);
.Ve
.PP
So you have three pairs.  The key of each pair (\*(L"file\*(R", \*(L"folder\*(R", \*(L"disk\*(R")
is the class.  The value of each pair (\*(L"foo\*(R", \*(L"bar\*(R", \*(L"baz\*(R") is the data.
Because the data are each text, the form defaults to formName,
and the data type defaults to typeChar (\s-1TEXT\s0).  If the data is
a number, then the form would be formAbsolutePosition, and the data type
would be typeLongInteger.
.PP
So that leaves only the container.  Each pair is contained by the pair
following it.  The disk contains the folder, the folder contains the file.
The disk has no container (its container is null).
.PP
Easy, right?  I hope so.  That's the idea.  But let's go back to the
forms, since that is the only tough part left.
.PP
The primary forms are types, names, unique IDs, absolute positions,
relative positions, tests, and ranges.  Normally, text data has form
name and type \s-1TEXT\s0.  Integer data has absolute position form, and
integer type.  The \f(CW\*(C`obj_form\*(C'\fR function (see \s-1EXPORT\s0) accepts three
parameters, which allows you to set the form and data, or form, type, and
data, in case you want to send data different from how Mac::Glue would guess.
.PP
These two are the same, since in the second case, the other is assumed:
.PP
.Vb 1
\&        use Mac::Glue \*(Aq:glue\*(Aq;
\&
\&        $obj1 = $glue\->obj(window =>
\&                obj_form(formAbsolutePostion, typeLongInteger, 1));
\&
\&        $obj2 = $glue\->obj(window => 1);
.Ve
.PP
Special constants are exported that specify relative positions and
absolute positions.
.PP
.Vb 2
\&        $first  = $glue\->obj(file => gFirst, property => \*(AqDesktop\*(Aq);
\&        $second = $glue\->obj(file => gNext, $first);
\&
\&        for ($first, $second) {
\&                print $glue\->get($_, as => \*(Aqstring\*(Aq);
\&        }
.Ve
.PP
\&\f(CW\*(C`of\*(C'\fR and \f(CW\*(C`in\*(C'\fR are synonyms of \f(CW\*(C`property\*(C'\fR:
.PP
.Vb 3
\&        $glue\->obj(file => gFirst, property => \*(AqDesktop\*(Aq);
\&        $glue\->obj(file => gFirst, of => \*(AqDesktop\*(Aq);
\&        $glue\->obj(file => gFirst, in => \*(AqDesktop\*(Aq);
.Ve
.PP
The \*(L"as\*(R" parameter above has a form of type, such as:
.PP
.Vb 1
\&        obj_form(formPropertyID, typeType, \*(Aqstring\*(Aq);
.Ve
.PP
Then \*(L"string\*(R" is turned into a four-character \s-1ID\s0 behind the scenes (in
this case, it is \*(L"\s-1TEXT\s0\*(R").
.PP
A special method called \f(CW\*(C`prop\*(C'\fR is for specifying properties.  These are
equivalent:
.PP
.Vb 2
\&        $glue\->obj(property => \*(AqDesktop\*(Aq);
\&        $glue\->prop(\*(AqDesktop\*(Aq);
.Ve
.SS "Descriptor types for object specifier records"
.IX Subsection "Descriptor types for object specifier records"
.IP "Property IDs" 4
.IX Item "Property IDs"
Normally, the glue will know a property is expected and coerce whatever
string you provide into its four-character \s-1ID\s0.  Sometimes
\&\f(CW\*(C`obj_form(formPropertyID, typeType, \*(Aqproperty_name\*(Aq)\*(C'\fR may be
appropriate.
.IP "Name" 4
.IX Item "Name"
Just pass the data as text.  If there is some ambiguity, you may explicitly
use \f(CW\*(C`obj_form(formName, typeChar, \*(Aqstring\*(Aq)\*(C'\fR.
.IP "Unique IDs" 4
.IX Item "Unique IDs"
Could be any type.  Usually you will need to use obj_form, else name or
absolute position will be used.  Use \f(CW\*(C`obj_form(formUniqueID, TYPE, DATA)\*(C'\fR.
.IP "Absolute position" 4
.IX Item "Absolute position"
As discussed above, if it is an index number, you can just pass the number,
as in \f(CW\*(C`window => 1\*(C'\fR, or you can explicitly mark it with
\&\f(CW\*(C`window => obj_form(formAbsolutePosition, typeLongInteger, 1)\*(C'\fR.
.Sp
For other absolutes, you may use constants, such as
\&\f(CW\*(C`window => gLast\*(C'\fR.  Choices are \f(CW\*(C`gFirst\*(C'\fR, \f(CW\*(C`gMiddle\*(C'\fR,
\&\f(CW\*(C`gLast\*(C'\fR, \f(CW\*(C`gAny\*(C'\fR, \f(CW\*(C`gAll\*(C'\fR.
.Sp
These are just shortcuts for explicit forms like
\&\f(CW\*(C`obj_form(formAbsolutePosition, typeAbsoluteOrdinal, kAEAll)\*(C'\fR.
.Sp
Note that if there is a plural form of the class name, you may use it
to mean the same thing as "\fIclass\fR => gAll".  These are all the
same:
.Sp
.Vb 3
\&        $f\->obj(files => of => \*(AqSystem Folder\*(Aq);
\&        $f\->obj(files => gAll, of => \*(AqSystem Folder\*(Aq);
\&        $f\->obj(file => gAll, of => \*(AqSystem Folder\*(Aq);
.Ve
.IP "Relative position" 4
.IX Item "Relative position"
Similar to absolute position, but an additional object must be
specified, such as \f(CW\*(C`file =\*(C'\fR gNext, file => gMiddle>, which would
return the file after the middle file.  Available constants are \f(CW\*(C`gNext\*(C'\fR
and \f(CW\*(C`gPrevious\*(C'\fR.
.Sp
The explicit form is \f(CW\*(C`obj_form(formRelativePosition, typeEnumerated, kAENext)\*(C'\fR.
.IP "Ranges" 4
.IX Item "Ranges"
The \f(CW\*(C`range\*(C'\fR function accepts two arguments, the start and stop ranges.
.Sp
.Vb 1
\&        range(START, STOP)
.Ve
.Sp
(See \s-1EXPORT\s0.)
.Sp
Each can be a number index, an absolute position constant, a string, or
another data type passed with \f(CW\*(C`obj_form\*(C'\fR.  Here are a few ways to specify
files in the System Folder:
.Sp
.Vb 4
\&        $f\->obj(files => range(1, 5), of => \*(AqSystem Folder\*(Aq);
\&        $f\->obj(files => range(1, "System"), of => \*(AqSystem Folder\*(Aq);
\&        $f\->obj(files => range("Finder", "System"), of => \*(AqSystem Folder\*(Aq);
\&        $f\->obj(files => range(gFirst, "System"), of => \*(AqSystem Folder\*(Aq);
.Ve
.IP "Whose tests" 4
.IX Item "Whose tests"
The \f(CW\*(C`whose\*(C'\fR function accepts either logical records or comparison
records.
.Sp
.Vb 3
\&        # comparison record
\&        $f\->obj(CLASS => whose(CLASS => VALUE, OPERATOR, VALUE));
\&        $f\->obj(CLASS => whose(PROPERTY, OPERATOR, VALUE));
.Ve
.Sp
(See \s-1EXPORT\s0.)
.Sp
\&\s-1PROPERTY\s0 and \s-1CLASS\s0 => \s-1VALUE\s0 work like \fIprop()\fR and \fIobj()\fR.  The \s-1PROPERTY\s0
form is the same as \f(CW\*(C`property => VALUE\*(C'\fR.
.Sp
\&\s-1OPERATOR\s0 is \f(CW\*(C`contains\*(C'\fR, \f(CW\*(C`equals\*(C'\fR, \f(CW\*(C`begins_with\*(C'\fR, \f(CW\*(C`ends_with\*(C'\fR,
\&\f(CW\*(C`l_t\*(C'\fR, \f(CW\*(C`l_e\*(C'\fR, \f(CW\*(C`g_t\*(C'\fR, or \f(CW\*(C`g_e\*(C'\fR.  \s-1VALUE\s0 is the value to compare to.
.Sp
.Vb 2
\&        # files whose name begins with "foo"
\&        $f\->obj(files => whose(name => begins_with => \*(Aqfoo\*(Aq));
\&
\&        # rows whose first cell equals "bar"
\&        $f\->obj(rows => whose(cell => 1 => equals => \*(Aqbar\*(Aq));
.Ve
.Sp
Then there is the logical record type, for use when more than one comparison
record is needed.
.Sp
.Vb 2
\&        # logical record
\&        $f\->obj(CLASS => whose(OPERATOR, LIST));
.Ve
.Sp
\&\s-1OPERATOR\s0 is \f(CW\*(C`AND\*(C'\fR, \f(CW\*(C`OR\*(C'\fR, or \f(CW\*(C`NOT\*(C'\fR.  \s-1LIST\s0 is any number of other logical
records or comparison records, contained in anonymous arrays.  So you can
join any number of records together:
.Sp
.Vb 6
\&        # words where it contains "e" and it begins with "p" and it does not end with "s"
\&        $aw\->obj(
\&                words => whose(AND =>
\&                        [it => contains => \*(Aqe\*(Aq], [it => begins_with => \*(Aqp\*(Aq],
\&                        [NOT => [it => ends_with => \*(Aqs\*(Aq]]
\&                ), $text)
.Ve
.Sp
Note how each logical record and comparison record following each logical
operator is in an anonymous array.  Also not how the special word \*(L"it\*(R"
refers to the object being examined.
.PP
There's one more record type that works similarly to the above object
specifier records, but is not exactly the same thing.
It's called an \fIinsertion location record\fR, and is created like this:
.PP
.Vb 1
\&        location(POSITION[, OBJECT])
.Ve
.PP
(See \s-1EXPORT\s0.)
.PP
\&\s-1POSITION\s0 is a string, and can be one of \f(CW\*(C`before\*(C'\fR, \f(CW\*(C`after\*(C'\fR, \f(CW\*(C`beginning\*(C'\fR,
or \f(CW\*(C`end\*(C'\fR.  \f(CW\*(C`front\*(C'\fR is a synonym for \f(CW\*(C`beginning\*(C'\fR, and \f(CW\*(C`back\*(C'\fR and \f(CW\*(C`behind\*(C'\fR
are synonyms for \f(CW\*(C`after\*(C'\fR.
.PP
\&\s-1OBJECT\s0 is the object to be positioned against, and will be the null object
if not supplied.
.PP
.Vb 3
\&        my $aw = new Mac::Glue \*(AqAppleWorks\*(Aq;
\&        my $text = $aw\->prop(text_body => document => 1);
\&        $aw\->activate;
\&
\&        # note null object in location()
\&        $aw\->make(new => \*(Aqdocument\*(Aq, at => location(\*(Aqfront\*(Aq));
\&        $aw\->set($text, to => "foo bar buz baz.");
\&
\&        $aw\->move(
\&                $aw\->obj(word => 4 => $text),
\&                to => location(after => $aw\->obj(word => 2 => $text))
\&        );
.Ve
.SS "Shortcuts for object specifier records"
.IX Subsection "Shortcuts for object specifier records"
Object specifier records objects in Mac::Glue can be called with any
method from the record's parent glue, and it will be passed to that
method as the direct object.  Examples:
.PP
.Vb 2
\&        $tracks = $itunes\->obj(tracks => $library);
\&        $tracks = $library\->obj(\*(Aqtracks\*(Aq);
\&
\&        @tracks = $itunes\->get($tracks);
\&        @tracks = $tracks\->get;
\&
\&        $itunes\->play($tracks[0]);
\&        $tracks[0]\->play;
.Ve
.PP
In the first example, the record \f(CW$library\fR is the direct object in the
\&\fIobj()\fR method, and so it can be flipped around with \f(CW\*(C`$library\-\*(C'\fRobj('tracks')>.
.PP
Then, in the second example, the resulting record, \f(CW$tracks\fR, is
called as the direct object of \fIget()\fR.
.PP
Similar is the third example, where the track we wish to play is the direct
object of \fIplay()\fR.
.SS "Data from object specifier records"
.IX Subsection "Data from object specifier records"
Sometimes data will be returned from an application in an object specifier
record, and you want to get the data underneath.  This isn't usually necessary,
but it came up in the case of iPhoto, where iPhoto would return a 64\-bit
integer, but want a 32\-bit integer or float to be sent back to it.
.PP
Normally, just using the object specifier record the app returned should be
sufficient, but in this case, it isn't.
.PP
Example:
.PP
.Vb 5
\&        # how it should work
\&        my $sel = $iphoto\->prop(\*(Aqselection\*(Aq);
\&        for my $photo ($sel\->get) {
\&                # ... do stuff with $photo
\&        }
\&
\&        # how it works
\&        my $sel = $iphoto\->prop(\*(Aqselection\*(Aq);
\&        for my $photo ($sel\->get) {
\&                my $id = $photo\->getdata; # get data in usable form
\&                my $newphoto = $iphoto\->obj(photo =>
\&                        obj_form(formUniqueID, typeFloat, $id)
\&                );
\&                # ... do stuff with $newphoto
\&        }
.Ve
.PP
Another workaround is to merely act on the object without fetching it.
.PP
.Vb 2
\&        my $sel = $iphoto\->prop(\*(Aqselection\*(Aq);
\&        # ... do stuff with $sel
.Ve
.PP
Results may vary.
.SS "Special parameters and methods"
.IX Subsection "Special parameters and methods"
Special parameters can be passed in the event which control certain
aspects of the event call's behavior.  They can be passed as parameters
(affecting only the one event), or called as methods (which affect every
call made from that object).  They are all upper case.
.PP
.Vb 2
\&        $glue\->REPLY(1);                # wait for reply on all events
\&        $glue\->close(REPLY => 0);       # don\*(Aqt wait for this one event
.Ve
.IP "\s-1REPLY\s0" 4
.IX Item "REPLY"
Boolean, for whether or not to wait for a reply.  Default is to wait.
.IP "\s-1MODE\s0" 4
.IX Item "MODE"
Set other modes, such as \f(CW\*(C`kAENeverInteract\*(C'\fR.  This value is \s-1OR\s0'd
together with the \s-1REPLY\s0 value.  Default is \f(CW\*(C`kAECanSwitchLayer\*(C'\fR.
.IP "\s-1SWITCH\s0" 4
.IX Item "SWITCH"
Switch to the application being called.  Usually more efficient to use
the \f(CW\*(C`activate\*(C'\fR event:
.Sp
.Vb 1
\&        $glue\->activate;
.Ve
.IP "\s-1PRIORITY\s0" 4
.IX Item "PRIORITY"
Set the event priority.  Default is \f(CW\*(C`kAENormalPriority\*(C'\fR.
.IP "\s-1TIMEOUT\s0" 4
.IX Item "TIMEOUT"
Number of seconds to wait before timing out.  Default is a couple
hundred thousand seconds or so.
.IP "\s-1RETOBJ\s0" 4
.IX Item "RETOBJ"
Boolean, for whether or not the event call will return the direct object
data (the default), or a Mac::AppleEvents::Simple object, containing
references to the actual event and reply, so you can do more advanced
things with the data if you want to.
.IP "\s-1ERRORS\s0" 4
.IX Item "ERRORS"
A subroutine reference that will handle any errors (that is, will
be executed only if \f(CW$^E\fR is true) after the event is executed.
Your handler will be passed a hashref as its first argument, containing
basic information about the event and error, followed by whatever
arguments were passed to the event.  The hashref keys are:
.Sp
.Vb 9
\&        _glue     actual glue object
\&        _event    Mac::AppleEvents::Simple object that produced the error
\&        glue      name of the application glue
\&        event     name of the event
\&        errs      error string
\&        errn      error number
\&        line      line of the error
\&        filename  filename of the error
\&        package   package of the error
.Ve
.Sp
If \s-1ERRORS\s0 is passed a value of \f(CW1\fR, then the default error handler will be used.
It is the same as the example error handler below.
.Sp
Example:
.Sp
.Vb 8
\&        sub error_handler {
\&                my($err, @args) = @_;
\&                my $args = join \*(Aq, \*(Aq, @args;
\&                warn sprintf("%s\->%s(%s) event failed:\en%s (%d)\en%s\en",
\&                        $err\->{glue}, $err\->{event}, $args,
\&                        $err\->{errc}, $err\->{errn}, $err\->{errs}
\&                );
\&        }
\&
\&        $finder\->open(
\&                $finder\->obj( item => \*(AqHD\*(Aq ), # nothing named HD in Finder
\&                ERRORS => \e&error_handler
\&        );
.Ve
.Sp
Result:
.Sp
.Vb 4
\&        Finder\->(DOBJ, Mac::AEObjDesc=HASH(0xb0dc30)) event failed (\-1728):
\&        errAENoSuchObject
\&        e.g.,: specifier asked for the 3rd, but there are only 2. Basically,
\&        this indicates a run\-time resolution error.
.Ve
.IP "launch" 4
.IX Item "launch"
\&\f(CW\*(C`launch()\*(C'\fR will launch the app, if it is not already launched.  This is
rarely necessary, as it is done automatically when needed.
.IP "version" 4
.IX Item "version"
\&\f(CW\*(C`version()\*(C'\fR gets the application's version, unpacking the data as
necessary, because the data is sometimes returned in a binary format.
.IP "app_process" 4
.IX Item "app_process"
\&\f(CW\*(C`app_process()\*(C'\fR returns the reference to the application process object
in the System Events application.  See \f(CW\*(C`gluedoc System_Events\*(C'\fR for more
information.  Example to hide the application:
.Sp
.Vb 1
\&        $glue\->app_process\->prop(\*(Aqvisible\*(Aq)\->set(to => 0);
.Ve
.SS "Editing a Glue"
.IX Subsection "Editing a Glue"
There is an included droplet, \fIglueedit\fR, for editing glues.  Drop
a created glue on the droplet, and it will make a text file on the
Desktop.  Edit it, and then drop the text file back on the droplet.
Be careful; this obviously can be dangerous.  If you break something,
you can use \fIgluemac\fR to recreate the original glue, of course.
.PP
Why would you edit a glue?  Well, sometimes \s-1AETE\s0 resources are wrong.  :)
.SH "EXPORT"
.IX Header "EXPORT"
Mac::Glue has two export sets.  \f(CW\*(C`glue\*(C'\fR exports the constants
and functions beginning with \*(L"glue\*(R" listed in
\&\*(L"Creating Object Specifier Records\*(R", as well as the functions
\&\f(CW\*(C`obj_form\*(C'\fR, \f(CW\*(C`enum\*(C'\fR, \f(CW\*(C`location\*(C'\fR, \f(CW\*(C`range\*(C'\fR, and \f(CW\*(C`whose\*(C'\fR.
\&\f(CW\*(C`all\*(C'\fR exports everything from Mac::AppleEvents and
Mac::AppleEvents::Simple, including all functions and constants.
Nothing is exported by default.
.PP
.Vb 2
\&        use Mac::Glue \*(Aq:glue\*(Aq;  # good for most things
\&        use Mac::Glue \*(Aq:all\*(Aq;   # for more advanced things
.Ve
.SH "TIPS"
.IX Header "TIPS"
.SS "Hide background apps"
.IX Subsection "Hide background apps"
.Vb 5
\&        use Mac::Glue;
\&        use Mac::Apps::Launch;
\&        $a = new Mac::Glue \*(AqAcrobat Exchange\*(Aq;
\&        $a\->launch;
\&        Hide($a\->{ID});
\&
\&        # now do your thing ...
.Ve
.PP
(This won't work on Mac \s-1OS\s0 X for now.)
.SS "Updating Glues"
.IX Subsection "Updating Glues"
Use the \-c and \-r flags in \fIgluemac\fR to update glues, either updating all
(with \-r) glues, or just those apps with versions different from those stored
in the glues.
.PP
To update scripting additions or the dialect (which probably should be done
when adding new scripting additions, or updating the system software),
run \fIgluescriptadds\fR and \fIgluedialect\fR.
.SS "Scripting Addition Maintenance"
.IX Subsection "Scripting Addition Maintenance"
If you have a lot of scripting additions, it can slow down Mac::Glue
(on startup) and take up more \s-1RAM\s0.  Same thing goes for Mac \s-1OS\s0 in general;
each installed additions takes up more \s-1RAM\s0 and has to be loaded into
the system, taking up extra time.  So only keep installed the ones
you want installed.
.PP
If you have a huge scripting addition and you only want to use a small
part of its functionality, you could also edit the glue and strip
out portions you don't want.  This is not recommended for those who
don't know precisely what they are doing, and the gains may be
unnoticable anyway.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
.IP "\(bu" 4
\&\s-1MAKE\s0 \s-1SURE\s0 \fIsite_perl\fR \s-1COMES\s0 \s-1FIRST\s0 \s-1IN\s0 \s-1YOUR\s0 \s-1LIBRARY\s0 \s-1PREFERENCES\s0 \s-1FOR\s0 \s-1OLD\s0
\&\s-1VERSIONS\s0 \s-1OF\s0 \s-1MACPERL\s0.  Thank you.  :\-)
.IP "\(bu" 4
Do \s-1NOT\s0 send an event to the MacPerl application itself and expect a reply.
Instead, try \f(CW\*(C`$macperlglue\->REPLY(0)\*(C'\fR.  Similarly, do not drop
MacPerl onto \fIgluemac\fR.  Instead, you can make a copy of the MacPerl
application, and drop that on \fIgluemac\fR.
.IP "\(bu" 4
You should have the latest cpan-mac distribution is installed, for old
versions of MacPerl.
.IP "\(bu" 4
You should delete old dialect glue files manually if running Mac \s-1OS\s0 9.
.SH "TODO / BUGS"
.IX Header "TODO / BUGS"
.IP "\(bu" 4
Specifying other attributes (transactions, etc.)
.IP "\(bu" 4
Add more coercions etc. to Mac::AppleEvents::Simple (feedback
wanted on this, let me know what I missed)
.IP "\(bu" 4
Add comparison operators from glues ?
.IP "\(bu" 4
\&\*(L"tell\*(R" objects to do events
.IP "\(bu" 4
New \s-1AETE\s0 flags in Mac \s-1OS\s0 8.5, Mac \s-1OS\s0 9?  Anything else new?  Anything
missing in backward compatibility to 7.5?
.IP "\(bu" 4
MacPerl (I think) needs a new idle function for waiting for
replies
.IP "\(bu" 4
MacPerl hangs if it waits for a reply after sending an event to
itself
.IP "\(bu" 4
Handlers (on foo ...) ?
.IP "\(bu" 4
Callbacks (some support exists, Cameron Ashby <cameron@evolution.com>,
see Mac::AppleEvents::Simple) ?
.IP "\(bu" 4
Add dynamic fetching of glues?
.IP "\(bu" 4
Make makefile stuff work with MacPerl (5.2 and 5.6 ?)
.IP "\(bu" 4
More \s-1POD\s0 in modules
.IP "\(bu" 4
More examples (iCal, iPhoto, iTunes)
.IP "\(bu" 4
A real test suite (though just making sure it loads is a pretty good test :\-)
.IP "\(bu" 4
Update glueedit
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Nandor <pudge@pobox.com>, http://pudge.net/
.PP
Copyright (c) 1998\-2005 Chris Nandor.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
.SH "THANKS"
.IX Header "THANKS"
Matthias Neeracher,
David Schooley,
Graham Barr,
John W Baxter,
Marion Delgado,
Eric Dobbs,
Josh Gemmell,
Alex Harper,
Nathaniel Irons,
Dave Johnson,
Bart Lateur,
Andy Lester,
Jefferson R. Lowrey,
Mat Marcus,
Larry Moore,
Ricardo Muggli,
Vincent Nonnenmacher,
Henry Penninkilampi,
Peter Prymmer,
Ramesh R.,
Axel Rose,
Stephan Somogyi,
Kevin Walker,
Matthew Wickline,
Simon Cozens,
has,
Bill Birkett,
Lars Eggert,
wren argetlahm,
Ken Williams,
Alan Olsen,
Chris Devers,
Kim Helliwell,
Jelte Liebrand.
.PP
(If I left your name out, please remind me.)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mac::AppleEvents, Mac::AppleEvents::Simple, macperlcat, Inside Macintosh: 
Interapplication Communication.
.PP
.Vb 1
\&        http://projects.pudge.net/
.Ve
