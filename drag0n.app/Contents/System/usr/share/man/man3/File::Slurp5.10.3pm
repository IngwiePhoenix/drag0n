.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Slurp 3"
.TH File::Slurp 3 "2008-01-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Slurp \- Efficient Reading/Writing of Complete Files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use File::Slurp;
\&
\&  my $text = read_file( \*(Aqfilename\*(Aq ) ;
\&  my @lines = read_file( \*(Aqfilename\*(Aq ) ;
\&
\&  write_file( \*(Aqfilename\*(Aq, @lines ) ;
\&
\&  use File::Slurp qw( slurp ) ;
\&
\&  my $text = slurp( \*(Aqfilename\*(Aq ) ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides subs that allow you to read or write entire files
with one simple call. They are designed to be simple to use, have
flexible ways to pass in or get the file contents and to be very
efficient.  There is also a sub to read in all the files in a
directory other than \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR
.PP
These slurp/spew subs work for files, pipes and
sockets, and stdio, pseudo-files, and \s-1DATA\s0.
.SS "\fBread_file\fP"
.IX Subsection "read_file"
This sub reads in an entire file and returns its contents to the
caller. In list context it will return a list of lines (using the
current value of $/ as the separator including support for paragraph
mode when it is set to ''). In scalar context it returns the entire
file as a single scalar.
.PP
.Vb 2
\&  my $text = read_file( \*(Aqfilename\*(Aq ) ;
\&  my @lines = read_file( \*(Aqfilename\*(Aq ) ;
.Ve
.PP
The first argument to \f(CW\*(C`read_file\*(C'\fR is the filename and the rest of the
arguments are key/value pairs which are optional and which modify the
behavior of the call. Other than binmode the options all control how
the slurped file is returned to the caller.
.PP
If the first argument is a file handle reference or I/O object (if ref
is true), then that handle is slurped in. This mode is supported so
you slurp handles such as \f(CW\*(C`DATA\*(C'\fR, \f(CW\*(C`STDIN\*(C'\fR. See the test handle.t
for an example that does \f(CW\*(C`open( \*(Aq\-|\*(Aq )\*(C'\fR and child process spews data
to the parant which slurps it in.  All of the options that control how
the data is returned to the caller still work in this case.
.PP
\&\s-1NOTE:\s0 as of version 9999.06, read_file works correctly on the \f(CW\*(C`DATA\*(C'\fR
handle. It used to need a sysseek workaround but that is now handled
when needed by the module itself.
.PP
You can optionally request that \f(CW\*(C`slurp()\*(C'\fR is exported to your code. This
is an alias for read_file and is meant to be forward compatible with
Perl 6 (which will have \fIslurp()\fR built-in).
.PP
The options are:
.PP
\fIbinmode\fR
.IX Subsection "binmode"
.PP
If you set the binmode option, then the file will be slurped in binary
mode.
.PP
.Vb 1
\&        my $bin_data = read_file( $bin_file, binmode => \*(Aq:raw\*(Aq ) ;
.Ve
.PP
\&\s-1NOTE:\s0 this actually sets the O_BINARY mode flag for sysopen. It
probably should call binmode and pass its argument to support other
file modes.
.PP
\fIarray_ref\fR
.IX Subsection "array_ref"
.PP
If this boolean option is set, the return value (only in scalar
context) will be an array reference which contains the lines of the
slurped file. The following two calls are equivalent:
.PP
.Vb 2
\&        my $lines_ref = read_file( $bin_file, array_ref => 1 ) ;
\&        my $lines_ref = [ read_file( $bin_file ) ] ;
.Ve
.PP
\fIscalar_ref\fR
.IX Subsection "scalar_ref"
.PP
If this boolean option is set, the return value (only in scalar
context) will be an scalar reference to a string which is the contents
of the slurped file. This will usually be faster than returning the
plain scalar.
.PP
.Vb 1
\&        my $text_ref = read_file( $bin_file, scalar_ref => 1 ) ;
.Ve
.PP
\fIbuf_ref\fR
.IX Subsection "buf_ref"
.PP
You can use this option to pass in a scalar reference and the slurped
file contents will be stored in the scalar. This can be used in
conjunction with any of the other options.
.PP
.Vb 3
\&        my $text_ref = read_file( $bin_file, buf_ref => \e$buffer,
\&                                             array_ref => 1 ) ;
\&        my @lines = read_file( $bin_file, buf_ref => \e$buffer ) ;
.Ve
.PP
\fIblk_size\fR
.IX Subsection "blk_size"
.PP
You can use this option to set the block size used when slurping from an already open handle (like \e*STDIN). It defaults to 1MB.
.PP
.Vb 2
\&        my $text_ref = read_file( $bin_file, blk_size => 10_000_000,
\&                                             array_ref => 1 ) ;
.Ve
.PP
\fIerr_mode\fR
.IX Subsection "err_mode"
.PP
You can use this option to control how read_file behaves when an error
occurs. This option defaults to 'croak'. You can set it to 'carp' or
to 'quiet to have no error handling. This code wants to carp and then
read abother file if it fails.
.PP
.Vb 2
\&        my $text_ref = read_file( $file, err_mode => \*(Aqcarp\*(Aq ) ;
\&        unless ( $text_ref ) {
\&
\&                # read a different file but croak if not found
\&                $text_ref = read_file( $another_file ) ;
\&        }
\&        
\&        # process ${$text_ref}
.Ve
.SS "\fBwrite_file\fP"
.IX Subsection "write_file"
This sub writes out an entire file in one call.
.PP
.Vb 1
\&  write_file( \*(Aqfilename\*(Aq, @data ) ;
.Ve
.PP
The first argument to \f(CW\*(C`write_file\*(C'\fR is the filename. The next argument
is an optional hash reference and it contains key/values that can
modify the behavior of \f(CW\*(C`write_file\*(C'\fR. The rest of the argument list is
the data to be written to the file.
.PP
.Vb 2
\&  write_file( \*(Aqfilename\*(Aq, {append => 1 }, @data ) ;
\&  write_file( \*(Aqfilename\*(Aq, {binmode => \*(Aq:raw\*(Aq }, $buffer ) ;
.Ve
.PP
As a shortcut if the first data argument is a scalar or array
reference, it is used as the only data to be written to the file. Any
following arguments in \f(CW@_\fR are ignored. This is a faster way to pass in
the output to be written to the file and is equivilent to the
\&\f(CW\*(C`buf_ref\*(C'\fR option. These following pairs are equivilent but the pass
by reference call will be faster in most cases (especially with larger
files).
.PP
.Vb 2
\&  write_file( \*(Aqfilename\*(Aq, \e$buffer ) ;
\&  write_file( \*(Aqfilename\*(Aq, $buffer ) ;
\&
\&  write_file( \*(Aqfilename\*(Aq, \e@lines ) ;
\&  write_file( \*(Aqfilename\*(Aq, @lines ) ;
.Ve
.PP
If the first argument is a file handle reference or I/O object (if ref
is true), then that handle is slurped in. This mode is supported so
you spew to handles such as \e*STDOUT. See the test handle.t for an
example that does \f(CW\*(C`open( \*(Aq\-|\*(Aq )\*(C'\fR and child process spews data to the
parant which slurps it in.  All of the options that control how the
data is passes into \f(CW\*(C`write_file\*(C'\fR still work in this case.
.PP
\&\f(CW\*(C`write_file\*(C'\fR returns 1 upon successfully writing the file or undef if
it encountered an error.
.PP
The options are:
.PP
\fIbinmode\fR
.IX Subsection "binmode"
.PP
If you set the binmode option, then the file will be written in binary
mode.
.PP
.Vb 1
\&        write_file( $bin_file, {binmode => \*(Aq:raw\*(Aq}, @data ) ;
.Ve
.PP
\&\s-1NOTE:\s0 this actually sets the O_BINARY mode flag for sysopen. It
probably should call binmode and pass its argument to support other
file modes.
.PP
\fIbuf_ref\fR
.IX Subsection "buf_ref"
.PP
You can use this option to pass in a scalar reference which has the
data to be written. If this is set then any data arguments (including
the scalar reference shortcut) in \f(CW@_\fR will be ignored. These are
equivilent:
.PP
.Vb 3
\&        write_file( $bin_file, { buf_ref => \e$buffer } ) ;
\&        write_file( $bin_file, \e$buffer ) ;
\&        write_file( $bin_file, $buffer ) ;
.Ve
.PP
\fIatomic\fR
.IX Subsection "atomic"
.PP
If you set this boolean option, the file will be written to in an
atomic fashion. A temporary file name is created by appending the pid
($$) to the file name argument and that file is spewed to. After the
file is closed it is renamed to the original file name (and rename is
an atomic operation on most \s-1OS\s0's). If the program using this were to
crash in the middle of this, then the file with the pid suffix could
be left behind.
.PP
\fIappend\fR
.IX Subsection "append"
.PP
If you set this boolean option, the data will be written at the end of
the current file.
.PP
.Vb 1
\&        write_file( $file, {append => 1}, @data ) ;
.Ve
.PP
\&\f(CW\*(C`write_file\*(C'\fR croaks if it cannot open the file. It returns true if it
succeeded in writing out the file and undef if there was an
error. (Yes, I know if it croaks it can't return anything but that is
for when I add the options to select the error handling mode).
.PP
\fIno_clobber\fR
.IX Subsection "no_clobber"
.PP
If you set this boolean option, an existing file will not be overwritten.
.PP
.Vb 1
\&        write_file( $file, {no_clobber => 1}, @data ) ;
.Ve
.PP
\fIerr_mode\fR
.IX Subsection "err_mode"
.PP
You can use this option to control how \f(CW\*(C`write_file\*(C'\fR behaves when an
error occurs. This option defaults to 'croak'. You can set it to
\&'carp' or to 'quiet' to have no error handling other than the return
value. If the first call to \f(CW\*(C`write_file\*(C'\fR fails it will carp and then
write to another file. If the second call to \f(CW\*(C`write_file\*(C'\fR fails, it
will croak.
.PP
.Vb 1
\&        unless ( write_file( $file, { err_mode => \*(Aqcarp\*(Aq, \e$data ) ;
\&
\&                # write a different file but croak if not found
\&                write_file( $other_file, \e$data ) ;
\&        }
.Ve
.SS "overwrite_file"
.IX Subsection "overwrite_file"
This sub is just a typeglob alias to write_file since write_file
always overwrites an existing file. This sub is supported for
backwards compatibility with the original version of this module. See
write_file for its \s-1API\s0 and behavior.
.SS "append_file"
.IX Subsection "append_file"
This sub will write its data to the end of the file. It is a wrapper
around write_file and it has the same \s-1API\s0 so see that for the full
documentation. These calls are equivilent:
.PP
.Vb 2
\&        append_file( $file, @data ) ;
\&        write_file( $file, {append => 1}, @data ) ;
.Ve
.SS "read_dir"
.IX Subsection "read_dir"
This sub reads all the file names from directory and returns them to
the caller but \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR are removed by default.
.PP
.Vb 1
\&        my @files = read_dir( \*(Aq/path/to/dir\*(Aq ) ;
.Ve
.PP
It croaks if it cannot open the directory.
.PP
In a list context \f(CW\*(C`read_dir\*(C'\fR returns a list of the entries in the
directory. In a scalar context it returns an array reference which has
the entries.
.PP
\fIkeep_dot_dot\fR
.IX Subsection "keep_dot_dot"
.PP
If this boolean option is set, \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR are not removed from the
list of files.
.PP
.Vb 1
\&        my @all_files = read_dir( \*(Aq/path/to/dir\*(Aq, keep_dot_dot => 1 ) ;
.Ve
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
.Vb 1
\&  read_file write_file overwrite_file append_file read_dir
.Ve
.SS "\s-1SEE\s0 \s-1ALSO\s0"
.IX Subsection "SEE ALSO"
An article on file slurping in extras/slurp_article.pod. There is
also a benchmarking script in extras/slurp_bench.pl.
.SS "\s-1BUGS\s0"
.IX Subsection "BUGS"
If run under Perl 5.004, slurping from the \s-1DATA\s0 handle will fail as
that requires B.pm which didn't get into core until 5.005.
.SH "AUTHOR"
.IX Header "AUTHOR"
Uri Guttman, <uri@stemsystems.com>
