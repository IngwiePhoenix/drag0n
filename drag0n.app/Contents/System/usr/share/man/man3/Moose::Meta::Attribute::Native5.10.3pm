.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Meta::Attribute::Native 3"
.TH Moose::Meta::Attribute::Native 3 "2010-03-26" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Meta::Attribute::Native \- Extend your attribute interfaces
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyClass;
\&  use Moose;
\&
\&  has \*(Aqmapping\*(Aq => (
\&      traits    => [ \*(AqHash\*(Aq ],
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqHashRef[Str]\*(Aq,
\&      default   => sub { {} },
\&      handles   => {
\&          exists_in_mapping => \*(Aqexists\*(Aq,
\&          ids_in_mapping    => \*(Aqkeys\*(Aq,
\&          get_mapping       => \*(Aqget\*(Aq,
\&          set_mapping       => \*(Aqset\*(Aq,
\&          set_quantity      => [ set => \*(Aqquantity\*(Aq ],
\&      },
\&  );
\&
\&
\&  # ...
\&
\&  my $obj = MyClass\->new;
\&  $obj\->set_quantity(10);      # quantity => 10
\&  $obj\->set_mapping(\*(Aqfoo\*(Aq, 4); # foo => 4
\&  $obj\->set_mapping(\*(Aqbar\*(Aq, 5); # bar => 5
\&  $obj\->set_mapping(\*(Aqbaz\*(Aq, 6); # baz => 6
\&
\&
\&  # prints 5
\&  print $obj\->get_mapping(\*(Aqbar\*(Aq) if $obj\->exists_in_mapping(\*(Aqbar\*(Aq);
\&
\&  # prints \*(Aqquantity, foo, bar, baz\*(Aq
\&  print join \*(Aq, \*(Aq, $obj\->ids_in_mapping;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
While Moose attributes provide a way to name your accessors, readers,
writers, clearers and predicates, this set of traits provides commonly
used attribute helper methods for more specific types of data.
.PP
As seen in the \*(L"\s-1SYNOPSIS\s0\*(R", you specify the data structure via the
\&\f(CW\*(C`trait\*(C'\fR parameter. Available traits are below; see \*(L"\s-1METHOD\s0 \s-1PROVIDERS\s0\*(R".
.PP
This module used to exist as the MooseX::AttributeHelpers extension. It was
very commonly used, so we moved it into core Moose. Since this gave us a chance
to change the interface, you will have to change your code or continue using
the MooseX::AttributeHelpers extension. MooseX::AttributeHelpers should
continue to work.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
.SS "handles"
.IX Subsection "handles"
This is like \f(CW\*(C`handles\*(C'\fR in \*(L"has\*(R" in Moose, but only \s-1HASH\s0 references are
allowed.  Keys are method names that you want installed locally, and values are
methods from the method providers (below).  Currying with delegated methods
works normally for \f(CW\*(C`handles\*(C'\fR.
.SH "METHOD PROVIDERS"
.IX Header "METHOD PROVIDERS"
.IP "Number" 4
.IX Item "Number"
Common numerical operations.
.Sp
.Vb 10
\&    has \*(Aqinteger\*(Aq => (
\&        traits    => [\*(AqNumber\*(Aq],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqInt\*(Aq,
\&        default   => 5,
\&        handles   => {
\&            set => \*(Aqset\*(Aq,
\&            add => \*(Aqadd\*(Aq,
\&            sub => \*(Aqsub\*(Aq,
\&            mul => \*(Aqmul\*(Aq,
\&            div => \*(Aqdiv\*(Aq,
\&            mod => \*(Aqmod\*(Aq,
\&            abs => \*(Aqabs\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.IP "String" 4
.IX Item "String"
Common methods for string operations.
.Sp
.Vb 11
\&    has \*(Aqtext\*(Aq => (
\&        traits    => [\*(AqString\*(Aq],
\&        is        => \*(Aqrw\*(Aq,
\&        isa       => \*(AqStr\*(Aq,
\&        default   => q{},
\&        handles   => {
\&            add_text     => \*(Aqappend\*(Aq,
\&            replace_text => \*(Aqreplace\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.IP "Counter" 4
.IX Item "Counter"
Methods for incrementing and decrementing a counter attribute.
.Sp
.Vb 12
\&    has \*(Aqcounter\*(Aq => (
\&        traits    => [\*(AqCounter\*(Aq],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqNum\*(Aq,
\&        default   => 0,
\&        handles   => {
\&            inc_counter   => \*(Aqinc\*(Aq,
\&            dec_counter   => \*(Aqdec\*(Aq,
\&            reset_counter => \*(Aqreset\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.IP "Bool" 4
.IX Item "Bool"
Common methods for boolean values.
.Sp
.Vb 10
\&    has \*(Aqis_lit\*(Aq => (
\&        traits    => [\*(AqBool\*(Aq],
\&        is        => \*(Aqrw\*(Aq,
\&        isa       => \*(AqBool\*(Aq,
\&        default   => 0,
\&        handles   => {
\&            illuminate  => \*(Aqset\*(Aq,
\&            darken      => \*(Aqunset\*(Aq,
\&            flip_switch => \*(Aqtoggle\*(Aq,
\&            is_dark     => \*(Aqnot\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.IP "Hash" 4
.IX Item "Hash"
Common methods for hash references.
.Sp
.Vb 12
\&    has \*(Aqoptions\*(Aq => (
\&        traits    => [\*(AqHash\*(Aq],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqHashRef[Str]\*(Aq,
\&        default   => sub { {} },
\&        handles   => {
\&            set_option => \*(Aqset\*(Aq,
\&            get_option => \*(Aqget\*(Aq,
\&            has_option => \*(Aqexists\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.IP "Array" 4
.IX Item "Array"
Common methods for array references.
.Sp
.Vb 11
\&    has \*(Aqqueue\*(Aq => (
\&        traits    => [\*(AqArray\*(Aq],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqArrayRef[Str]\*(Aq,
\&        default   => sub { [] },
\&        handles   => {
\&            add_item  => \*(Aqpush\*(Aq,
\&            next_item => \*(Aqshift\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.IP "Code" 4
.IX Item "Code"
Common methods for code references.
.Sp
.Vb 10
\&    has \*(Aqcallback\*(Aq => (
\&        traits    => [\*(AqCode\*(Aq],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqCodeRef\*(Aq,
\&        default   => sub { sub { \*(Aqcalled\*(Aq } },
\&        handles   => {
\&            call => \*(Aqexecute\*(Aq,
\&            # ...
\&        }
\&    );
.Ve
.SH "BUGS"
.IX Header "BUGS"
See \*(L"\s-1BUGS\s0\*(R" in Moose for details on reporting bugs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.PP
\&\fBwith contributions from:\fR
.PP
Robert (rlb3) Boone
.PP
Paul (frodwith) Driver
.PP
Shawn (Sartak) Moore
.PP
Chris (perigrin) Prather
.PP
Robert (phaylon) Sedlacek
.PP
Tom (dec) Lanyon
.PP
Yuval Kogman
.PP
Jason May
.PP
Cory (gphat) Watson
.PP
Florian (rafl) Ragwitz
.PP
Evan Carroll
.PP
Jesse (doy) Luehrs
.PP
Jay Hannah
.PP
Robert Buels
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2009 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
