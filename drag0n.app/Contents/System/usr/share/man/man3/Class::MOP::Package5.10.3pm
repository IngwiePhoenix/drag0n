.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::MOP::Package 3"
.TH Class::MOP::Package 3 "2010-03-25" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MOP::Package \- Package Meta Object
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Package Protocol provides an abstraction of a Perl 5 package. A
package is basically namespace, and this module provides methods for
looking at and changing that namespace's symbol table.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBClass::MOP::Package\->initialize($package_name)\fR" 4
.IX Item "Class::MOP::Package->initialize($package_name)"
This method creates a new \f(CW\*(C`Class::MOP::Package\*(C'\fR instance which
represents specified package. If an existing metaclass object exists
for the package, that will be returned instead.
.IP "\fBClass::MOP::Package\->reinitialize($package)\fR" 4
.IX Item "Class::MOP::Package->reinitialize($package)"
This method forcibly removes any existing metaclass for the package
before calling \f(CW\*(C`initialize\*(C'\fR. In contrast to \f(CW\*(C`initialize\*(C'\fR, you may
also pass an existing \f(CW\*(C`Class::MOP::Package\*(C'\fR instance instead of just
a package name as \f(CW$package\fR.
.Sp
Do not call this unless you know what you are doing.
.ie n .IP "\fB\fB$metapackage\fB\->name\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->name\fR" 4
.IX Item "$metapackage->name"
This is returns the package's name, as passed to the constructor.
.ie n .IP "\fB\fB$metapackage\fB\->namespace\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->namespace\fR" 4
.IX Item "$metapackage->namespace"
This returns a hash reference to the package's symbol table. The keys
are symbol names and the values are typeglob references.
.ie n .IP "\fB\fB$metapackage\fB\->add_package_symbol($variable_name, \f(BI$initial_value\fB)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->add_package_symbol($variable_name, \f(CB$initial_value\fB)\fR" 4
.IX Item "$metapackage->add_package_symbol($variable_name, $initial_value)"
This method accepts a variable name and an optional initial value. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.Sp
This method creates the variable in the package's symbol table, and
sets it to the initial value if one was provided.
.ie n .IP "\fB\fB$metapackage\fB\->get_package_symbol($variable_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->get_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->get_package_symbol($variable_name)"
Given a variable name, this method returns the variable as a reference
or undef if it does not exist. The \f(CW$variable_name\fR must contain a
leading sigil.
.ie n .IP "\fB\fB$metapackage\fB\->has_package_symbol($variable_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->has_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->has_package_symbol($variable_name)"
Returns true if there is a package variable defined for
\&\f(CW$variable_name\fR. The \f(CW$variable_name\fR must contain a leading sigil.
.ie n .IP "\fB\fB$metapackage\fB\->remove_package_symbol($variable_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->remove_package_symbol($variable_name)\fR" 4
.IX Item "$metapackage->remove_package_symbol($variable_name)"
This will remove the package variable specified \f(CW$variable_name\fR. The
\&\f(CW$variable_name\fR must contain a leading sigil.
.ie n .IP "\fB\fB$metapackage\fB\->remove_package_glob($glob_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->remove_package_glob($glob_name)\fR" 4
.IX Item "$metapackage->remove_package_glob($glob_name)"
Given the name of a glob, this will remove that glob from the
package's symbol table. Glob names do not include a sigil. Removing
the glob removes all variables and subroutines with the specified
name.
.ie n .IP "\fB\fB$metapackage\fB\->list_all_package_symbols($type_filter)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->list_all_package_symbols($type_filter)\fR" 4
.IX Item "$metapackage->list_all_package_symbols($type_filter)"
This will list all the glob names associated with the current
package. These names do not have leading sigils.
.Sp
You can provide an optional type filter, which should be one of
\&'\s-1SCALAR\s0', '\s-1ARRAY\s0', '\s-1HASH\s0', or '\s-1CODE\s0'.
.ie n .IP "\fB\fB$metapackage\fB\->get_all_package_symbols($type_filter)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->get_all_package_symbols($type_filter)\fR" 4
.IX Item "$metapackage->get_all_package_symbols($type_filter)"
This works much like \f(CW\*(C`list_all_package_symbols\*(C'\fR, but it returns a
hash reference. The keys are glob names and the values are references
to the value for that name.
.SS "Method introspection and creation"
.IX Subsection "Method introspection and creation"
These methods allow you to introspect a class's methods, as well as
add, remove, or change methods.
.PP
Determining what is truly a method in a Perl 5 class requires some
heuristics (aka guessing).
.PP
Methods defined outside the package with a fully qualified name (\f(CW\*(C`sub
Package::name { ... }\*(C'\fR) will be included. Similarly, methods named
with a fully qualified name using Sub::Name are also included.
.PP
However, we attempt to ignore imported functions.
.PP
Ultimately, we are using heuristics to determine what truly is a
method in a class, and these heuristics may get the wrong answer in
some edge cases. However, for most \*(L"normal\*(R" cases the heuristics work
correctly.
.ie n .IP "\fB\fB$metapackage\fB\->get_method($method_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->get_method($method_name)\fR" 4
.IX Item "$metapackage->get_method($method_name)"
This will return a Class::MOP::Method for the specified
\&\f(CW$method_name\fR. If the class does not have the specified method, it
returns \f(CW\*(C`undef\*(C'\fR
.ie n .IP "\fB\fB$metapackage\fB\->has_method($method_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->has_method($method_name)\fR" 4
.IX Item "$metapackage->has_method($method_name)"
Returns a boolean indicating whether or not the class defines the
named method. It does not include methods inherited from parent
classes.
.ie n .IP "\fB\fB$metapackage\fB\->get_method_list\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->get_method_list\fR" 4
.IX Item "$metapackage->get_method_list"
This will return a list of method \fInames\fR for all methods defined in
this class.
.ie n .IP "\fB\fB$metapackage\fB\->add_method($method_name, \f(BI$method\fB)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->add_method($method_name, \f(CB$method\fB)\fR" 4
.IX Item "$metapackage->add_method($method_name, $method)"
This method takes a method name and a subroutine reference, and adds
the method to the class.
.Sp
The subroutine reference can be a Class::MOP::Method, and you are
strongly encouraged to pass a meta method object instead of a code
reference. If you do so, that object gets stored as part of the
class's method map directly. If not, the meta information will have to
be recreated later, and may be incorrect.
.Sp
If you provide a method object, this method will clone that object if
the object's package name does not match the class name. This lets us
track the original source of any methods added from other classes
(notably Moose roles).
.ie n .IP "\fB\fB$metapackage\fB\->remove_method($method_name)\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->remove_method($method_name)\fR" 4
.IX Item "$metapackage->remove_method($method_name)"
Remove the named method from the class. This method returns the
Class::MOP::Method object for the method.
.ie n .IP "\fB\fB$metapackage\fB\->method_metaclass\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->method_metaclass\fR" 4
.IX Item "$metapackage->method_metaclass"
Returns the class name of the method metaclass, see
Class::MOP::Method for more information on the method metaclass.
.ie n .IP "\fB\fB$metapackage\fB\->wrapped_method_metaclass\fR" 4
.el .IP "\fB\f(CB$metapackage\fB\->wrapped_method_metaclass\fR" 4
.IX Item "$metapackage->wrapped_method_metaclass"
Returns the class name of the wrapped method metaclass, see
Class::MOP::Method::Wrapped for more information on the wrapped
method metaclass.
.IP "\fBClass::MOP::Package\->meta\fR" 4
.IX Item "Class::MOP::Package->meta"
This will return a Class::MOP::Class instance for this class.
.SH "AUTHORS"
.IX Header "AUTHORS"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2010 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
