.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Meta::Attribute::Native::Trait::Array 3"
.TH Moose::Meta::Attribute::Native::Trait::Array 3 "2010-03-26" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Meta::Attribute::Native::Trait::Array \- Helper trait for ArrayRef attributes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Stuff;
\&    use Moose;
\&
\&    has \*(Aqoptions\*(Aq => (
\&       traits     => [\*(AqArray\*(Aq],
\&       is         => \*(Aqro\*(Aq,
\&       isa        => \*(AqArrayRef[Str]\*(Aq,
\&       default    => sub { [] },
\&       handles    => {
\&           all_options    => \*(Aqelements\*(Aq,
\&           add_option     => \*(Aqpush\*(Aq,
\&           map_options    => \*(Aqmap\*(Aq,
\&           filter_options => \*(Aqgrep\*(Aq,
\&           find_option    => \*(Aqfirst\*(Aq,
\&           get_option     => \*(Aqget\*(Aq,
\&           join_options   => \*(Aqjoin\*(Aq,
\&           count_options  => \*(Aqcount\*(Aq,
\&           has_options    => \*(Aqcount\*(Aq,
\&           has_no_options => \*(Aqis_empty\*(Aq,
\&           sorted_options => \*(Aqsort\*(Aq,
\&       },
\&    );
\&
\&    no Moose;
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an Array attribute which provides a number of
array operations.
.SH "PROVIDED METHODS"
.IX Header "PROVIDED METHODS"
These methods are implemented in
Moose::Meta::Attribute::Native::MethodProvider::Array.
.IP "\fBcount\fR" 4
.IX Item "count"
Returns the number of elements in the array.
.Sp
.Vb 2
\&   $stuff = Stuff\->new;
\&   $stuff\->options(["foo", "bar", "baz", "boo"]);
\&
\&   my $count = $stuff\->count_options;
\&   print "$count\en"; # prints 4
.Ve
.IP "\fBis_empty\fR" 4
.IX Item "is_empty"
Returns a boolean value that is true when the array has no elements.
.Sp
.Vb 1
\&   $stuff\->has_no_options ? die "No options!\en" : print "Good boy.\en";
.Ve
.IP "\fBelements\fR" 4
.IX Item "elements"
Returns all of the elements of the array.
.Sp
.Vb 2
\&   my @option = $stuff\->all_options;
\&   print "@options\en"; # prints "foo bar baz boo"
.Ve
.IP "\fBget($index)\fR" 4
.IX Item "get($index)"
Returns an element of the array by its index. You can also use negative index
numbers, just as with Perl's core array handling.
.Sp
.Vb 2
\&   my $option = $stuff\->get_option(1);
\&   print "$option\en"; # prints "bar"
.Ve
.IP "\fBpop\fR" 4
.IX Item "pop"
.PD 0
.ie n .IP "\fBpush($value1, \fB$value2\fB, value3 ...)\fR" 4
.el .IP "\fBpush($value1, \f(CB$value2\fB, value3 ...)\fR" 4
.IX Item "push($value1, $value2, value3 ...)"
.IP "\fBshift\fR" 4
.IX Item "shift"
.ie n .IP "\fBunshift($value1, \fB$value2\fB, value3 ...)\fR" 4
.el .IP "\fBunshift($value1, \f(CB$value2\fB, value3 ...)\fR" 4
.IX Item "unshift($value1, $value2, value3 ...)"
.ie n .IP "\fBsplice($offset, \fB$length\fB, \f(BI@values\fB)\fR" 4
.el .IP "\fBsplice($offset, \f(CB$length\fB, \f(CB@values\fB)\fR" 4
.IX Item "splice($offset, $length, @values)"
.PD
These methods are all equivalent to the Perl core functions of the same name.
.IP "\fBfirst( sub { ... } )\fR" 4
.IX Item "first( sub { ... } )"
This method returns the first item matching item in the array, just like
List::Util's \f(CW\*(C`first\*(C'\fR function. The matching is done with a subroutine
reference you pass to this method. The reference will be called against each
element in the array until one matches or all elements have been checked.
.Sp
.Vb 2
\&   my $found = $stuff\->find_option( sub { /^b/ } );
\&   print "$found\en"; # prints "bar"
.Ve
.IP "\fBgrep( sub { ... } )\fR" 4
.IX Item "grep( sub { ... } )"
This method returns every element matching a given criteria, just like Perl's
core \f(CW\*(C`grep\*(C'\fR function. This method requires a subroutine which implements the
matching logic.
.Sp
.Vb 2
\&   my @found = $stuff\->filter_options( sub { /^b/ } );
\&   print "@found\en"; # prints "bar baz boo"
.Ve
.IP "\fBmap( sub { ... } )\fR" 4
.IX Item "map( sub { ... } )"
This method transforms every element in the array and returns a new array,
just like Perl's core \f(CW\*(C`map\*(C'\fR function. This method requires a subroutine which
implements the transformation.
.Sp
.Vb 2
\&   my @mod_options = $stuff\->map_options( sub { $_ . "\-tag" } );
\&   print "@mod_options\en"; # prints "foo\-tag bar\-tag baz\-tag boo\-tag"
.Ve
.IP "\fBreduce( sub { ... } )\fR" 4
.IX Item "reduce( sub { ... } )"
This method condenses an array into a single value, by passing a function the
value so far and the next value in the array, just like List::Util's
\&\f(CW\*(C`reduce\*(C'\fR function. The reducing is done with a subroutine reference you pass
to this method.
.Sp
.Vb 2
\&   my $found = $stuff\->reduce_options( sub { $_[0] . $_[1] } );
\&   print "$found\en"; # prints "foobarbazboo"
.Ve
.IP "\fBsort( sub { ... } )\fR" 4
.IX Item "sort( sub { ... } )"
Returns a the array in sorted order.
.Sp
You can provide an optional subroutine reference to sort with (as you can with
Perl's core \f(CW\*(C`sort\*(C'\fR function). However, instead of using \f(CW$a\fR and \f(CW$b\fR, you
will need to use \f(CW$_[0]\fR and \f(CW$_[1]\fR instead.
.Sp
.Vb 2
\&   # ascending ASCIIbetical
\&   my @sorted = $stuff\->sort_options();
\&
\&   # Descending alphabetical order
\&   my @sorted_options = $stuff\->sort_options( sub { lc $_[1] cmp lc $_[0] } );
\&   print "@sorted_options\en"; # prints "foo boo baz bar"
.Ve
.IP "\fBsort_in_place\fR" 4
.IX Item "sort_in_place"
Sorts the array \fIin place\fR, modifying the value of the attribute.
.Sp
You can provide an optional subroutine reference to sort with (as you can with
Perl's core \f(CW\*(C`sort\*(C'\fR function). However, instead of using \f(CW$a\fR and \f(CW$b\fR, you
will need to use \f(CW$_[0]\fR and \f(CW$_[1]\fR instead.
.IP "\fBshuffle\fR" 4
.IX Item "shuffle"
Returns the array, with indices in random order, like \f(CW\*(C`shuffle\*(C'\fR from
List::Util.
.IP "\fBuniq\fR" 4
.IX Item "uniq"
Returns the array, with all duplicate elements removed, like \f(CW\*(C`uniq\*(C'\fR from
List::MoreUtils.
.IP "\fBjoin($str)\fR" 4
.IX Item "join($str)"
Joins every element of the array using the separator given as argument, just
like Perl's core \f(CW\*(C`join\*(C'\fR function.
.Sp
.Vb 2
\&   my $joined = $stuff\->join_options( \*(Aq:\*(Aq );
\&   print "$joined\en"; # prints "foo:bar:baz:boo"
.Ve
.ie n .IP "\fBset($index, \fB$value\fB)\fR" 4
.el .IP "\fBset($index, \f(CB$value\fB)\fR" 4
.IX Item "set($index, $value)"
Given an index and a value, sets the specified array element's value.
.IP "\fBdelete($index)\fR" 4
.IX Item "delete($index)"
Removes the element at the given index from the array.
.ie n .IP "\fBinsert($index, \fB$value\fB)\fR" 4
.el .IP "\fBinsert($index, \f(CB$value\fB)\fR" 4
.IX Item "insert($index, $value)"
Inserts a new element into the array at the given index.
.IP "\fBclear\fR" 4
.IX Item "clear"
Empties the entire array, like \f(CW\*(C`@array = ()\*(C'\fR.
.IP "\fBaccessor\fR" 4
.IX Item "accessor"
This method provides a get/set accessor for the array, based on array indexes.
If passed one argument, it returns the value at the specified index.  If
passed two arguments, it sets the value of the specified index.
.ie n .IP "\fBnatatime($n, \fB$code\fB)\fR" 4
.el .IP "\fBnatatime($n, \f(CB$code\fB)\fR" 4
.IX Item "natatime($n, $code)"
This method returns an iterator which, on each call, returns \f(CW$n\fR more items
from the array, in order, like \f(CW\*(C`natatime\*(C'\fR from List::MoreUtils. A coderef
can optionally be provided; it will be called on each group of \f(CW$n\fR elements
in the array.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBmethod_provider\fR" 4
.IX Item "method_provider"
.IP "\fBhas_method_provider\fR" 4
.IX Item "has_method_provider"
.PD
.SH "BUGS"
.IX Header "BUGS"
See \*(L"\s-1BUGS\s0\*(R" in Moose for details on reporting bugs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2009 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
