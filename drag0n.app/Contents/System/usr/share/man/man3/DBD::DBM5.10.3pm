.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::DBM 3"
.TH DBD::DBM 3 "2008-01-31" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::DBM \- a DBI driver for DBM & MLDBM files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\& use DBI;
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(AqDBI:DBM(RaiseError=1):\*(Aq);  # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:type=GDBM_File\*(Aq);  # defaults to GDBM_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:mldbm=Storable\*(Aq);  # MLDBM with SDBM_File
\&                                                 # and Storable
.Ve
.PP
or
.PP
.Vb 2
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef);
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { dbm_type => \*(AqODBM_File\*(Aq });
.Ve
.PP
and other variations on \fIconnect()\fR as shown in the \s-1DBI\s0 docs and with
the dbm_ attributes shown below
.PP
\&... and then use standard \s-1DBI\s0 prepare, execute, fetch, placeholders, etc.,
see \*(L"\s-1QUICK\s0 \s-1START\s0\*(R" for an example
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DBD::DBM\s0 is a database management sytem that can work right out of the box.  If you have a standard installation of Perl and a standard installation of \s-1DBI\s0, you can begin creating, accessing, and modifying database tables without any further installation.  You can also add some other modules to it for more robust capabilities if you wish.
.PP
The module uses a \s-1DBM\s0 file storage layer.  \s-1DBM\s0 file storage is common on many platforms and files can be created with it in many languges.  That means that, in addition to creating files with \s-1DBI/SQL\s0, you can also use \s-1DBI/SQL\s0 to access and modify files created by other \s-1DBM\s0 modules and programs.  You can also use those programs to access files created with \s-1DBD::DBM\s0.
.PP
\&\s-1DBM\s0 files are stored in binary format optimized for quick retrieval when using a key field.  That optimization can be used advantageously to make \s-1DBD::DBM\s0 \s-1SQL\s0 operations that use key fields very fast.  There are several different \*(L"flavors\*(R" of \s-1DBM\s0 \- different storage formats supported by different sorts of perl modules such as SDBM_File and \s-1MLDBM\s0.  This module supports all of the flavors that perl supports and, when used with \s-1MLDBM\s0, supports tables with any number of columns and insertion of Perl objects into tables.
.PP
\&\s-1DBD::DBM\s0 has been tested with the following \s-1DBM\s0 types: SDBM_File, NDBM_File, ODBM_File, GDBM_File, DB_File, BerekeleyDB.  Each type was tested both with and without \s-1MLDBM\s0.
.SH "QUICK START"
.IX Header "QUICK START"
\&\s-1DBD::DBM\s0 operates like all other \s-1DBD\s0 drivers \- it's basic syntax and operation is specified by \s-1DBI\s0.  If you're not familiar with \s-1DBI\s0, you should start by reading \s-1DBI\s0 and the documents it points to and then come back and read this file.  If you are familiar with \s-1DBI\s0, you already know most of what you need to know to operate this module.  Just jump in and create a test script something like the one shown below.
.PP
You should be aware that there are several options for the \s-1SQL\s0 engine underlying \s-1DBD::DBM\s0, see \*(L"Supported \s-1SQL\s0 syntax\*(R".  There are also many options for \s-1DBM\s0 support, see especially the section on \*(L"Adding multi-column support with \s-1MLDBM\s0\*(R".
.PP
But here's a sample to get you started.
.PP
.Vb 10
\& use DBI;
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->{RaiseError} = 1;
\& for my $sql( split /;\en+/,"
\&     CREATE TABLE user ( user_name TEXT, phone TEXT );
\&     INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\&     INSERT INTO user VALUES (\*(AqSanjay Patel\*(Aq,\*(Aq777\-3333\*(Aq);
\&     INSERT INTO user VALUES (\*(AqJunk\*(Aq,\*(Aqxxx\-xxxx\*(Aq);
\&     DELETE FROM user WHERE user_name = \*(AqJunk\*(Aq;
\&     UPDATE user SET phone = \*(Aq999\-4444\*(Aq WHERE user_name = \*(AqSanjay Patel\*(Aq;
\&     SELECT * FROM user
\& "){
\&     my $sth = $dbh\->prepare($sql);
\&     $sth\->execute;
\&     $sth\->dump_results if $sth\->{NUM_OF_FIELDS};
\& }
\& $dbh\->disconnect;
.Ve
.SH "USAGE"
.IX Header "USAGE"
.SS "Specifiying Files and Directories"
.IX Subsection "Specifiying Files and Directories"
\&\s-1DBD::DBM\s0 will automatically supply an appropriate file extension for the type of \s-1DBM\s0 you are using.  For example, if you use SDBM_File, a table called \*(L"fruit\*(R" will be stored in two files called \*(L"fruit.pag\*(R" and \*(L"fruit.dir\*(R".  You should \fInever\fR specify the file extensions in your \s-1SQL\s0 statements.
.PP
However, I am not aware (and therefore \s-1DBD::DBM\s0 is not aware) of all possible extensions for various \s-1DBM\s0 types.  If your \s-1DBM\s0 type uses an extension other than .pag and .dir, you should set the \fIdbm_ext\fR attribute to the extension. \fBAnd\fR you should write me with the name of the implementation and extension so I can add it to \s-1DBD::DBM\s0!  Thanks in advance for that :\-).
.PP
.Vb 2
\&    $dbh = DBI\->connect(\*(Aqdbi:DBM:ext=.db\*(Aq);  # .db extension is used
\&    $dbh = DBI\->connect(\*(Aqdbi:DBM:ext=\*(Aq);     # no extension is used
.Ve
.PP
or
.PP
.Vb 2
\&    $dbh\->{dbm_ext}=\*(Aq.db\*(Aq;                      # global setting
\&    $dbh\->{dbm_tables}\->{\*(Aqqux\*(Aq}\->{ext}=\*(Aq.db\*(Aq;   # setting for table \*(Aqqux\*(Aq
.Ve
.PP
By default files are assumed to be in the current working directory.  To have the module look in a different directory, specify the \fIf_dir\fR attribute in either the connect string or by setting the database handle attribute.
.PP
For example, this will look for the file /foo/bar/fruit (or /foo/bar/fruit.pag for \s-1DBM\s0 types that use that extension)
.PP
.Vb 2
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:f_dir=/foo/bar\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{ SELECT * FROM fruit });
.Ve
.PP
And this will too:
.PP
.Vb 3
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   $dbh\->{f_dir} = \*(Aq/foo/bar\*(Aq;
\&   my $ary = $dbh\->selectall_arrayref(q{ SELECT x FROM fruit });
.Ve
.PP
You can also use delimited identifiers to specify paths directly in \s-1SQL\s0 statements.  This looks in the same place as the two examples above but without setting \fIf_dir\fR:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT x FROM "/foo/bar/fruit"
\&   });
.Ve
.PP
If you have SQL::Statement installed, you can use table aliases:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT f.x FROM "/foo/bar/fruit" AS f
\&   });
.Ve
.PP
See the \*(L"\s-1GOTCHAS\s0 \s-1AND\s0 \s-1WARNINGS\s0\*(R" for using \s-1DROP\s0 on tables.
.SS "Table locking and \fIflock()\fP"
.IX Subsection "Table locking and flock()"
Table locking is accomplished using a lockfile which has the same name as the table's file but with the file extension '.lck' (or a lockfile extension that you suppy, see belwo).  This file is created along with the table during a \s-1CREATE\s0 and removed during a \s-1DROP\s0.  Every time the table itself is opened, the lockfile is \fIflocked()\fR.  For \s-1SELECT\s0, this is an shared lock.  For all other operations, it is an exclusive lock.
.PP
Since the locking depends on \fIflock()\fR, it only works on operating systems that support \fIflock()\fR.  In cases where \fIflock()\fR is not implemented, \s-1DBD::DBM\s0 will not complain, it will simply behave as if the \fIflock()\fR had occurred although no actual locking will happen.  Read the documentation for \fIflock()\fR if you need to understand this.
.PP
Even on those systems that do support \fIflock()\fR, the locking is only advisory \- as is allways the case with \fIflock()\fR.  This means that if some other program tries to access the table while \s-1DBD::DBM\s0 has the table locked, that other program will *succeed* at opening the table.  \s-1DBD::DBM\s0's locking only applies to \s-1DBD::DBM\s0.  An exception to this would be the situation in which you use a lockfile with the other program that has the same name as the lockfile used in \s-1DBD::DBM\s0 and that program also uses \fIflock()\fR on that lockfile.  In that case, \s-1DBD::DBM\s0 and your other program will respect each other's locks.
.PP
If you wish to use a lockfile extension other than '.lck', simply specify the dbm_lockfile attribute:
.PP
.Vb 3
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:lockfile=.foo\*(Aq);
\&  $dbh\->{dbm_lockfile} = \*(Aq.foo\*(Aq;
\&  $dbh\->{dbm_tables}\->{qux}\->{lockfile} = \*(Aq.foo\*(Aq;
.Ve
.PP
If you wish to disable locking, set the dbm_lockfile equal to 0.
.PP
.Vb 3
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:lockfile=0\*(Aq);
\&  $dbh\->{dbm_lockfile} = 0;
\&  $dbh\->{dbm_tables}\->{qux}\->{lockfile} = 0;
.Ve
.SS "Specifying the \s-1DBM\s0 type"
.IX Subsection "Specifying the DBM type"
Each \*(L"flavor\*(R" of \s-1DBM\s0 stores its files in a different format and has different capabilities and different limitations.  See AnyDBM_File for a comparison of \s-1DBM\s0 types.
.PP
By default, \s-1DBD::DBM\s0 uses the SDBM_File type of storage since SDBM_File comes with Perl itself.  But if you have other types of \s-1DBM\s0 storage available, you can use any of them with \s-1DBD::DBM\s0 also.
.PP
You can specify the \s-1DBM\s0 type using the \*(L"dbm_type\*(R" attribute which can be set in the connection string or with the \f(CW$dbh\fR\->{dbm_type} attribute for global settings or with the \f(CW$dbh\fR\->{dbm_tables}\->{$table_name}\->{type} attribute for per-table settings in cases where a single script is accessing more than one kind of \s-1DBM\s0 file.
.PP
In the connection string, just set type=TYPENAME where \s-1TYPENAME\s0 is any \s-1DBM\s0 type such as GDBM_File, DB_File, etc.  Do \fInot\fR use \s-1MLDBM\s0 as your dbm_type, that is set differently, see below.
.PP
.Vb 2
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:\*(Aq);               # uses the default SDBM_File
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:type=GDBM_File\*(Aq); # uses the GDBM_File
.Ve
.PP
You can also use \f(CW$dbh\fR\->{dbm_type} to set global \s-1DBM\s0 type:
.PP
.Vb 2
\& $dbh\->{dbm_type} = \*(AqGDBM_File\*(Aq;  # set the global DBM type
\& print $dbh\->{dbm_type};          # display the global DBM type
.Ve
.PP
If you are going to have several tables in your script that come from different \s-1DBM\s0 types, you can use the \f(CW$dbh\fR\->{dbm_tables} hash to store different settings for the various tables.  You can even use this to perform joins on files that have completely different storage mechanisms.
.PP
.Vb 3
\& my $dbh\->(\*(Aqdbi:DBM:type=GDBM_File\*(Aq);
\& #
\& # sets global default of GDBM_File
\&
\& my $dbh\->{dbm_tables}\->{foo}\->{type} = \*(AqDB_File\*(Aq;
\& #
\& # over\-rides the global setting, but only for the table called "foo"
\&
\& print $dbh\->{dbm_tables}\->{foo}\->{type};
\& #
\& # prints the dbm_type for the table "foo"
.Ve
.SS "Adding multi-column support with \s-1MLDBM\s0"
.IX Subsection "Adding multi-column support with MLDBM"
Most of the \s-1DBM\s0 types only support two columns.  However a \s-1CPAN\s0 module called \s-1MLDBM\s0 overcomes this limitation by allowing more than two columns.  It does this by serializing the data \- basically it puts a reference to an array into the second column.  It can also put almost any kind of Perl object or even Perl coderefs into columns.
.PP
If you want more than two columns, you must install \s-1MLDBM\s0.  It's available for many platforms and is easy to install.
.PP
\&\s-1MLDBM\s0 can use three different modules to serialize the column \- Data::Dumper, Storable, and FreezeThaw.  Data::Dumper is the default, Storable is the fastest.  \s-1MLDBM\s0 can also make use of user-defined serialization methods.  All of this is available to you through \s-1DBD::DBM\s0 with just one attribute setting.
.PP
To use \s-1MLDBM\s0 with \s-1DBD::DBM\s0, you need to set the dbm_mldbm attribute to the name of the serialization module.
.PP
Some examples:
.PP
.Vb 8
\& $dbh=DBI\->connect(\*(Aqdbi:DBM:mldbm=Storable\*(Aq);  # use MLDBM with Storable
\& $dbh=DBI\->connect(
\&    \*(Aqdbi:DBM:mldbm=MySerializer\*(Aq           # use MLDBM with a user defined module
\& );
\& $dbh\->{dbm_mldbm} = \*(AqMySerializer\*(Aq;       # same as above
\& print $dbh\->{dbm_mldbm}                   # show the MLDBM serializer
\& $dbh\->{dbm_tables}\->{foo}\->{mldbm}=\*(AqData::Dumper\*(Aq;   # set Data::Dumper for table "foo"
\& print $dbh\->{dbm_tables}\->{foo}\->{mldbm}; # show serializer for table "foo"
.Ve
.PP
\&\s-1MLDBM\s0 works on top of other \s-1DBM\s0 modules so you can also set a \s-1DBM\s0 type along with setting dbm_mldbm.  The examples above would default to using SDBM_File with \s-1MLDBM\s0.  If you wanted GDBM_File instead, here's how:
.PP
.Vb 3
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:type=GDBM_File;mldbm=Storable\*(Aq);
\& #
\& # uses GDBM_File with MLDBM and Storable
.Ve
.PP
SDBM_File, the default file type is quite limited, so if you are going to use \s-1MLDBM\s0, you should probably use a different type, see AnyDBM_File.
.PP
See below for some \*(L"\s-1GOTCHAS\s0 \s-1AND\s0 \s-1WARNINGS\s0\*(R" about \s-1MLDBM\s0.
.SS "Support for Berkeley \s-1DB\s0"
.IX Subsection "Support for Berkeley DB"
The Berkeley \s-1DB\s0 storage type is supported through two different Perl modules \- DB_File (which supports only features in old versions of Berkeley \s-1DB\s0) and BerkeleyDB (which supports all versions).  \s-1DBD::DBM\s0 supports specifying either \*(L"DB_File\*(R" or \*(L"BerkeleyDB\*(R" as a \fIdbm_type\fR, with or without \s-1MLDBM\s0 support.
.PP
The \*(L"BerkeleyDB\*(R" dbm_type is experimental and its interface is likely to chagne.  It currently defaults to BerkeleyDB::Hash and does not currently support ::Btree or ::Recno.
.PP
With BerkeleyDB, you can specify initialization flags by setting them in your script like this:
.PP
.Vb 9
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:type=BerkeleyDB;mldbm=Storable\*(Aq);
\& use BerkeleyDB;
\& my $env = new BerkeleyDB::Env \-Home => $dir;  # and/or other Env flags
\& $dbh\->{dbm_berkeley_flags} = {
\&      \*(AqDB_CREATE\*(Aq  => DB_CREATE  # pass in constants
\&    , \*(AqDB_RDONLY\*(Aq  => DB_RDONLY  # pass in constants
\&    , \*(Aq\-Cachesize\*(Aq => 1000       # set a ::Hash flag
\&    , \*(Aq\-Env\*(Aq       => $env       # pass in an environment
\& };
.Ve
.PP
Do \fInot\fR set the \-Flags or \-Filename flags, those are determined by the \s-1SQL\s0 (e.g. \-Flags => \s-1DB_RDONLY\s0 is set automatically when you issue a \s-1SELECT\s0 statement).
.PP
Time has not permitted me to provide support in this release of \s-1DBD::DBM\s0 for further Berkeley \s-1DB\s0 features such as transactions, concurrency, locking, etc.  I will be working on these in the future and would value suggestions, patches, etc.
.PP
See DB_File and BerkeleyDB for further details.
.SS "Supported \s-1SQL\s0 syntax"
.IX Subsection "Supported SQL syntax"
\&\s-1DBD::DBM\s0 uses a subset of \s-1SQL\s0.  The robustness of that subset depends on what other modules you have installed. Both options support basic \s-1SQL\s0 operations including \s-1CREATE\s0 \s-1TABLE\s0, \s-1DROP\s0 \s-1TABLE\s0, \s-1INSERT\s0, \s-1DELETE\s0, \s-1UPDATE\s0, and \s-1SELECT\s0.
.PP
\&\fBOption #1:\fR By default, this module inherits its \s-1SQL\s0 support from DBI::SQL::Nano that comes with \s-1DBI\s0.  Nano is, as its name implies, a *very* small \s-1SQL\s0 engine.  Although limited in scope, it is faster than option #2 for some operations.  See DBI::SQL::Nano for a description of the \s-1SQL\s0 it supports and comparisons of it with option #2.
.PP
\&\fBOption #2:\fR If you install the pure Perl \s-1CPAN\s0 module SQL::Statement, \s-1DBD::DBM\s0 will use it instead of Nano.  This adds support for table aliases, for functions, for joins, and much more.  If you're going to use \s-1DBD::DBM\s0 for anything other than very simple tables and queries, you should install SQL::Statement.  You don't have to change \s-1DBD::DBM\s0 or your scripts in any way, simply installing SQL::Statement will give you the more robust \s-1SQL\s0 capabilities without breaking scripts written for DBI::SQL::Nano.  See SQL::Statement for a description of the \s-1SQL\s0 it supports.
.PP
To find out which \s-1SQL\s0 module is working in a given script, you can use the \fIdbm_versions()\fR method or, if you don't need the full output and version numbers, just do this:
.PP
.Vb 1
\& print $dbh\->{sql_handler};
.Ve
.PP
That will print out either \*(L"SQL::Statement\*(R" or \*(L"DBI::SQL::Nano\*(R".
.SS "Optimizing use of key fields"
.IX Subsection "Optimizing use of key fields"
Most \*(L"flavors\*(R" of \s-1DBM\s0 have only two physical columns (but can contain multiple logical columns as explained below).  They work similarly to a Perl hash with the first column serving as the key.  Like a Perl hash, \s-1DBM\s0 files permit you to do quick lookups by specifying the key and thus avoid looping through all records.  Also like a Perl hash, the keys must be unique.  It is impossible to create two records with the same key.  To put this all more simply and in \s-1SQL\s0 terms, the key column functions as the \s-1PRIMARY\s0 \s-1KEY\s0.
.PP
In \s-1DBD::DBM\s0, you can take advantage of the speed of keyed lookups by using a \s-1WHERE\s0 clause with a single equal comparison on the key field.  For example, the following \s-1SQL\s0 statements are optimized for keyed lookup:
.PP
.Vb 4
\& CREATE TABLE user ( user_name TEXT, phone TEXT);
\& INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\& # ... many more inserts
\& SELECT phone FROM user WHERE user_name=\*(AqFred Bloggs\*(Aq;
.Ve
.PP
The \*(L"user_name\*(R" column is the key column since it is the first column. The \s-1SELECT\s0 statement uses the key column in a single equal comparision \- "user_name='Fred Bloggs' \- so the search will find it very quickly without having to loop through however many names were inserted into the table.
.PP
In contrast, thes searches on the same table are not optimized:
.PP
.Vb 2
\& 1. SELECT phone FROM user WHERE user_name < \*(AqFred\*(Aq;
\& 2. SELECT user_name FROM user WHERE phone = \*(Aq233\-7777\*(Aq;
.Ve
.PP
In #1, the operation uses a less-than (<) comparison rather than an equals comparison, so it will not be optimized for key searching.  In #2, the key field \*(L"user_name\*(R" is not specified in the \s-1WHERE\s0 clause, and therefore the search will need to loop through all rows to find the desired result.
.SS "Specifying Column Names"
.IX Subsection "Specifying Column Names"
\&\s-1DBM\s0 files don't have a standard way to store column names.   \s-1DBD::DBM\s0 gets around this issue with a \s-1DBD::DBM\s0 specific way of storing the column names.  \fBIf you are working only with \s-1DBD::DBM\s0 and not using files created by or accessed with other \s-1DBM\s0 programs, you can ignore this section.\fR
.PP
\&\s-1DBD::DBM\s0 stores column names as a row in the file with the key \fI_metadata \e0\fR.  So this code
.PP
.Vb 3
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->do("CREATE TABLE baz (foo CHAR(10), bar INTEGER)");
\& $dbh\->do("INSERT INTO baz (foo,bar) VALUES (\*(Aqzippy\*(Aq,1)");
.Ve
.PP
Will create a file that has a structure something like this:
.PP
.Vb 2
\&  _metadata \e0 | foo,bar
\&  zippy        | 1
.Ve
.PP
The next time you access this table with \s-1DBD::DBM\s0, it will treat the _metadata row as a header rather than as data and will pull the column names from there.  However, if you access the file with something other than \s-1DBD::DBM\s0, the row will be treated as a regular data row.
.PP
If you do not want the column names stored as a data row in the table you can set the \fIdbm_store_metadata\fR attribute to 0.
.PP
.Vb 1
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:store_metadata=0\*(Aq);
.Ve
.PP
or
.PP
.Vb 1
\& $dbh\->{dbm_store_metadata} = 0;
.Ve
.PP
or, for per-table setting
.PP
.Vb 1
\& $dbh\->{dbm_tables}\->{qux}\->{store_metadata} = 0;
.Ve
.PP
By default, \s-1DBD::DBM\s0 assumes that you have two columns named \*(L"k\*(R" and \*(L"v\*(R" (short for \*(L"key\*(R" and \*(L"value\*(R").  So if you have \fIdbm_store_metadata\fR set to 1 and you want to use alternate column names, you need to specify the column names like this:
.PP
.Vb 1
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:store_metadata=0;cols=foo,bar\*(Aq);
.Ve
.PP
or
.PP
.Vb 2
\& $dbh\->{dbm_store_metadata} = 0;
\& $dbh\->{dbm_cols}           = \*(Aqfoo,bar\*(Aq;
.Ve
.PP
To set the column names on per-table basis, do this:
.PP
.Vb 4
\& $dbh\->{dbm_tables}\->{qux}\->{store_metadata} = 0;
\& $dbh\->{dbm_tables}\->{qux}\->{cols}           = \*(Aqfoo,bar\*(Aq;
\& #
\& # sets the column names only for table "qux"
.Ve
.PP
If you have a file that was created by another \s-1DBM\s0 program or created with \fIdbm_store_metadata\fR set to zero and you want to convert it to using \s-1DBD::DBM\s0's column name storage, just use one of the methods above to name the columns but *without* specifying \fIdbm_store_metadata\fR as zero.  You only have to do that once \- thereafter you can get by without setting either \fIdbm_store_metadata\fR or setting \fIdbm_cols\fR because the names will be stored in the file.
.SS "Statement handle ($sth) attributes and methods"
.IX Subsection "Statement handle ($sth) attributes and methods"
Most statement handle attributes such as \s-1NAME\s0, \s-1NUM_OF_FIELDS\s0, etc. are available only after an execute.  The same is true of \f(CW$sth\fR\->rows which is available after the execute but does \fInot\fR require a fetch.
.ie n .SS "The $dbh\->\fIdbm_versions()\fP method"
.el .SS "The \f(CW$dbh\fP\->\fIdbm_versions()\fP method"
.IX Subsection "The $dbh->dbm_versions() method"
The private method \fIdbm_versions()\fR presents a summary of what other modules are being used at any given time.  \s-1DBD::DBM\s0 can work with or without many other modules \- it can use either SQL::Statement or DBI::SQL::Nano as its \s-1SQL\s0 engine, it can be run with \s-1DBI\s0 or DBI::PurePerl, it can use many kinds of \s-1DBM\s0 modules, and many kinds of serializers when run with \s-1MLDBM\s0.  The \fIdbm_versions()\fR method reports on all of that and more.
.PP
.Vb 2
\&  print $dbh\->dbm_versions;               # displays global settings
\&  print $dbh\->dbm_versions($table_name);  # displays per table settings
.Ve
.PP
An important thing to note about this method is that when called with no arguments, it displays the *global* settings.  If you over-ride these by setting per-table attributes, these will \fInot\fR be shown unless you specifiy a table name as an argument to the method call.
.SS "Storing Objects"
.IX Subsection "Storing Objects"
If you are using \s-1MLDBM\s0, you can use \s-1DBD::DBM\s0 to take advantage of its serializing abilities to serialize any Perl object that \s-1MLDBM\s0 can handle.  To store objects in columns, you should (but don't absolutely need to) declare it as a column of type \s-1BLOB\s0 (the type is *currently* ignored by the \s-1SQL\s0 engine, but heh, it's good form).
.PP
You *must* use placeholders to insert or refer to the data.
.SH "GOTCHAS AND WARNINGS"
.IX Header "GOTCHAS AND WARNINGS"
Using the \s-1SQL\s0 \s-1DROP\s0 command will remove any file that has the name specified in the command with either '.pag' or '.dir' or your {dbm_ext} appended to it.  So
this be dangerous if you aren't sure what file it refers to:
.PP
.Vb 1
\& $dbh\->do(qq{DROP TABLE "/path/to/any/file"});
.Ve
.PP
Each \s-1DBM\s0 type has limitations.  SDBM_File, for example, can only store values of less than 1,000 characters.  *You* as the script author must ensure that you don't exceed those bounds.  If you try to insert a value that is bigger than the \s-1DBM\s0 can store, the results will be unpredictable.  See the documentation for whatever \s-1DBM\s0 you are using for details.
.PP
Different \s-1DBM\s0 implementations return records in different orders.  That means that you can \fInot\fR depend on the order of records unless you use an \s-1ORDER\s0 \s-1BY\s0 statement.  DBI::SQL::Nano does not currently support \s-1ORDER\s0 \s-1BY\s0 (though it may soon) so if you need ordering, you'll have to install SQL::Statement.
.PP
\&\s-1DBM\s0 data files are platform-specific.  To move them from one platform to another, you'll need to do something along the lines of dumping your data to \s-1CSV\s0 on platform #1 and then dumping from \s-1CSV\s0 to \s-1DBM\s0 on platform #2.  DBD::AnyData and \s-1DBD::CSV\s0 can help with that.  There may also be \s-1DBM\s0 conversion tools for your platforms which would probably be quickest.
.PP
When using \s-1MLDBM\s0, there is a very powerful serializer \- it will allow you to store Perl code or objects in database columns.  When these get de-serialized, they may be evaled \- in other words \s-1MLDBM\s0 (or actually Data::Dumper when used by \s-1MLDBM\s0) may take the values and try to execute them in Perl.  Obviously, this can present dangers, so if you don't know what's in a file, be careful before you access it with \s-1MLDBM\s0 turned on!
.PP
See the entire section on \*(L"Table locking and \fIflock()\fR\*(R" for gotchas and warnings about the use of \fIflock()\fR.
.SH "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
.IX Header "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
If you need help installing or using \s-1DBD::DBM\s0, please write to the \s-1DBI\s0 users mailing list at dbi\-users@perl.org or to the comp.lang.perl.modules newsgroup on usenet.  I'm afraid I can't always answer these kinds of questions quickly and there are many on the mailing list or in the newsgroup who can.
.PP
If you have suggestions, ideas for improvements, or bugs to report, please write me directly at the email shown below.
.PP
When reporting bugs, please send the output of \f(CW$dbh\fR\->dbm_versions($table) for a table that exhibits the bug and, if possible, as small a sample as you can make of the code that produces the bug.  And of course, patches are welcome too :\-).
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Many, many thanks to Tim Bunce for prodding me to write this, and for copious, wise, and patient suggestions all along the way.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is written and maintained by
.PP
Jeff Zucker < jzucker \s-1AT\s0 cpan.org >
.PP
Copyright (c) 2004 by Jeff Zucker, all rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, SQL::Statement, DBI::SQL::Nano, AnyDBM_File, \s-1MLDBM\s0
