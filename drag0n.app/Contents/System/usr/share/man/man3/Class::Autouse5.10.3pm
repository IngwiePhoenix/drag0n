.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Autouse 3"
.TH Class::Autouse 3 "2007-11-11" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Autouse \- Run\-time load a class the first time you call a method in it.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # Debugging (if you go that way) must be set before the first use
\&  BEGIN {
\&      $Class::Autouse::DEBUG = 1;
\&  }
\&  
\&  # Load a class on method call
\&  use Class::Autouse;
\&  Class::Autouse\->autouse( \*(AqCGI\*(Aq );
\&  print CGI\->b(\*(AqWow!\*(Aq);
\&
\&  # Use as a pragma
\&  use Class::Autouse qw{CGI};
\&
\&  # Turn on developer mode
\&  use Class::Autouse qw{:devel};
\&
\&  # Turn on the Super Loader
\&  use Class::Autouse qw{:superloader};
\&  
\&  # Disable module\-existance check, and thus one additional \*(Aqstat\*(Aq
\&  # per module, at autouse\-time if loading modules off a remote
\&  # network drive such as NFS or SMB.
\&  use Class::Autouse qw{:nostat};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Class::Autouse\*(C'\fR allows you to specify a class the will only load when a
method of that class is called. For large classes that might not be used
during the running of a program, such as Date::Manip, this can save
you large amounts of memory, and decrease the script load time a great deal.
.SS "Class, not Module"
.IX Subsection "Class, not Module"
The terminology \*(L"class loading\*(R" instead of \*(L"module loading\*(R" is used
intentionally. Modules will only be loaded if they are acting as a class.
.PP
That is, they will only be loaded during a Class\->method call. If you try
to use a subroutine directly, say with \f(CW\*(C`Class::method()\*(C'\fR, the class will
not be loaded and a fatal error will mostly likely occur.
.PP
This limitation is made to allow more powerfull features in other areas,
because the module can focus on just loading the modules, and not have
to deal with importing.
.PP
And really, if you are doing \s-1OO\s0 Perl, you should be avoiding importing
wherever possible.
.SS "Use as a pragma"
.IX Subsection "Use as a pragma"
Class::Autouse can be used as a pragma, specifying a list of classes
to load as the arguments. For example
.PP
.Vb 1
\&   use Class::Autouse qw{CGI Data::Manip This::That};
.Ve
.PP
is equivalent to
.PP
.Vb 4
\&   use Class::Autouse;
\&   Class::Autouse\->autouse( \*(AqCGI\*(Aq         );
\&   Class::Autouse\->autouse( \*(AqData::Manip\*(Aq );
\&   Class::Autouse\->autouse( \*(AqThis::That\*(Aq  );
.Ve
.SS "Developer Mode"
.IX Subsection "Developer Mode"
\&\f(CW\*(C`Class::Autouse\*(C'\fR features a developer mode. In developer mode, classes
are loaded immediately, just like they would be with a normal 'use'
statement (although the import sub isn't called).
.PP
This allows error checking to be done while developing, at the expense of
a larger memory overhead. Developer mode is turned on either with the
\&\f(CW\*(C`devel\*(C'\fR method, or using :devel in any of the pragma arguments.
For example, this would load \s-1CGI\s0.pm immediately
.PP
.Vb 1
\&    use Class::Autouse qw{:devel CGI};
.Ve
.PP
While developer mode is roughly equivalent to just using a normal use
command, for a large number of modules it lets you use autoloading
notation, and just comment or uncomment a single line to turn developer
mode on or off. You can leave it on during development, and turn it
off for speed reasons when deploying.
.SS "No-Stat Mode"
.IX Subsection "No-Stat Mode"
For situations where a module exists on a remote disk or another relatively
expensive location, you can call \f(CW\*(C`Class::Autouse\*(C'\fR with the :nostat param
to disable initial file existance checking at hook time.
.PP
.Vb 2
\&  # Disable autoload\-time file existance checking
\&  use Class::Autouse qw{:nostat};
.Ve
.SS "Super Loader Mode"
.IX Subsection "Super Loader Mode"
Turning on the \f(CW\*(C`Class::Autouse\*(C'\fR super loader allows you to automatically
load \fB\s-1ANY\s0\fR class without specifying it first. Thus, the following will
work and is completely legal.
.PP
.Vb 1
\&    use Class::Autouse qw{:superloader};
\&
\&    print CGI\->b(\*(AqWow!\*(Aq);
.Ve
.PP
The super loader can be turned on with either the
\&\f(CW\*(C`Class::Autouse\->\*(C'\fRsuperloader> method, or the \f(CW\*(C`:superloader\*(C'\fR pragma
argument.
.PP
Please note that unlike the normal one-at-a-time autoloading, the
super-loader makes global changes, and so is not completely self-contained.
.PP
It has the potential to cause unintended effects at a distance. If you
encounter unusual behaviour, revert to autousing one-at-a-time, or use
the recursive loading.
.PP
Use of the Super Loader is highly discouraged for widely distributed
public applications or modules unless unavoidable. \fBDo not use\fR just
to be lazy and save a few lines of code.
.SS "Recursive Loading"
.IX Subsection "Recursive Loading"
As an alternative to the super loader, the \f(CW\*(C`autouse_recursive\*(C'\fR and
\&\f(CW\*(C`load_recursive\*(C'\fR methods can be used to autouse or load an entire tree
of classes.
.PP
For example, the following would give you access to all the \s-1URI\s0
related classes installed on the machine.
.PP
.Vb 1
\&    Class::Autouse\->autouse_recursive( \*(AqURI\*(Aq );
.Ve
.PP
Please note that the loadings will only occur down a single branch of the
include path, whichever the top class is located in.
.SS "mod_perl"
.IX Subsection "mod_perl"
The mechanism that \f(CW\*(C`Class::Autouse\*(C'\fR uses is not compatible with mod_perl.
In particular with reloader modules like Apache::Reload. \f(CW\*(C`Class::Autouse\*(C'\fR
detects the presence of mod_perl and acts as normal, but will always load
all classes immediately, equivalent to having developer mode enabled.
.PP
This is actually beneficial, as under mod_perl classes should be preloaded
in the parent mod_perl process anyway, to prevent them having to be loaded
by the Apache child classes. It also saves \s-1HUGE\s0 amounts of memory.
.SS "prefork"
.IX Subsection "prefork"
As for mod_perl, \f(CW\*(C`Class::Autouse\*(C'\fR is compatible with the prefork module,
and all modules autoloaded will be loaded before forking correctly, when
requested by prefork.
.SS "The Internal Debugger"
.IX Subsection "The Internal Debugger"
Class::Autouse provides an internal debugger, which can be used to debug
any weird edge cases you might encounter when using it.
.PP
If the \f(CW$Class::Autouse::DEBUG\fR variable is true when \f(CW\*(C`Class::Autouse\*(C'\fR
is first loaded, debugging will be compiled in. This debugging prints
output like the following to \s-1STDOUT\s0.
.PP
.Vb 9
\& Class::Autouse::autouse_recursive( \*(AqFoo\*(Aq )
\&  Class::Autouse::_recursive( \*(AqFoo\*(Aq, \*(Aqload\*(Aq )
\&   Class::Autouse::load( \*(AqFoo\*(Aq )
\&   Class::Autouse::_child_classes( \*(AqFoo\*(Aq )
\&   Class::Autouse::load( \*(AqFoo::Bar\*(Aq )
\&    Class::Autouse::_file_exists( \*(AqFoo/Bar.pm\*(Aq )
\&    Class::Autouse::load \-> Loading in Foo/Bar.pm
\&   Class::Autouse::load( \*(AqFoo::More\*(Aq )
\&    etc...
.Ve
.PP
Please note that because this is optimised out if not used, you can
no longer (since 1.20) enable debugging at run-time. This decision was
made to remove a large number of unneeded branching and speed up loading.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "autouse $class, ..."
.el .SS "autouse \f(CW$class\fP, ..."
.IX Subsection "autouse $class, ..."
The autouse method sets one or more classes to be loaded as required.
.ie n .SS "load $class"
.el .SS "load \f(CW$class\fP"
.IX Subsection "load $class"
The load method loads one or more classes into memory. This is functionally
equivalent to using require to load the class list in, except that load
will detect and remove the autoloading hook from a previously autoused
class, whereas as use effectively ignore the class, and not load it.
.SS "devel"
.IX Subsection "devel"
The devel method sets development mode on (argument of 1) or off
(argument of 0).
.PP
If any classes have previously been autouse'd and not loaded when this
method is called, they will be loaded immediately.
.SS "superloader"
.IX Subsection "superloader"
The superloader method turns on the super loader.
.PP
Please note that once you have turned the superloader on, it cannot be
turned off. This is due to code that might be relying on it being there not
being able to autoload its classes when another piece of code decides
they don't want it any more, and turns the superloader off.
.ie n .SS "class_exists $class"
.el .SS "class_exists \f(CW$class\fP"
.IX Subsection "class_exists $class"
Handy method when doing the sort of jobs that \f(CW\*(C`Class::Autouse\*(C'\fR does. Given
a class name, it will return true if the class can be loaded ( i.e. in \f(CW@INC\fR ),
false if the class can't be loaded, and undef if the class name is invalid.
.PP
Note that this does not actually load the class, just tests to see if it can
be loaded. Loading can still fail. For a more comprehensive set of methods
of this nature, see Class::Inspector.
.ie n .SS "autouse_recursive $class"
.el .SS "autouse_recursive \f(CW$class\fP"
.IX Subsection "autouse_recursive $class"
The same as the \f(CW\*(C`autouse\*(C'\fR method, but autouses recursively.
.ie n .SS "load_recursive $class"
.el .SS "load_recursive \f(CW$class\fP"
.IX Subsection "load_recursive $class"
The same as the \f(CW\*(C`load\*(C'\fR method, but loads recursively. Great for checking that
a large class tree that might not always be loaded will load correctly.
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be always be reported via the \s-1CPAN\s0 bug tracker at
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Class\-Autouse>
.PP
For other issues, or commercial enhancement or support, contact the author.
.SH "AUTHORS"
.IX Header "AUTHORS"
Adam Kennedy (Creator and Maintainer), <http://ali.as/>, cpan@ali.as
.PP
Rob Napier (No longer involved), rnapier@employees.org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
autoload, autoclass
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002 \- 2006 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
